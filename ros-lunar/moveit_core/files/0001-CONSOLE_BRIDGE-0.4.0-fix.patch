From 1582db946aa2c7743951f8bc1b554a72d791ffed Mon Sep 17 00:00:00 2001
From: "Hunter L. Allen" <hunter@openrobotics.org>
Date: Wed, 28 Feb 2018 14:49:00 -0500
Subject: [PATCH] CONSOLE_BRIDGE 0.4.0 fix.

---
 .../src/background_processing.cpp                  |  6 +-
 collision_detection/src/collision_matrix.cpp       |  4 +-
 .../src/collision_octomap_filter.cpp               | 10 +--
 collision_detection/src/collision_robot.cpp        |  8 +--
 collision_detection/src/world.cpp                  |  2 +-
 collision_detection_fcl/src/collision_common.cpp   | 32 +++++-----
 .../src/collision_robot_fcl.cpp                    | 12 ++--
 .../src/collision_world_fcl.cpp                    |  4 +-
 constraint_samplers/src/constraint_sampler.cpp     |  2 +-
 .../src/constraint_sampler_manager.cpp             | 30 ++++-----
 .../src/constraint_sampler_tools.cpp               |  4 +-
 .../src/default_constraint_samplers.cpp            | 32 +++++-----
 .../src/union_constraint_sampler.cpp               |  4 +-
 constraint_samplers/test/pr2_arm_ik.cpp            | 10 +--
 distance_field/src/distance_field.cpp              |  4 +-
 distance_field/src/propagation_distance_field.cpp  | 24 ++++----
 distance_field/test/test_distance_field.cpp        |  2 +-
 dynamics_solver/src/dynamics_solver.cpp            | 48 +++++++--------
 exceptions/src/exceptions.cpp                      |  4 +-
 kinematic_constraints/src/kinematic_constraint.cpp | 54 ++++++++--------
 kinematic_constraints/src/utils.cpp                |  2 +-
 kinematics_base/src/kinematics_base.cpp            |  4 +-
 kinematics_metrics/src/kinematics_metrics.cpp      |  8 +--
 planning_interface/src/planning_interface.cpp      |  2 +-
 .../src/planning_request_adapter.cpp               |  4 +-
 planning_scene/src/planning_scene.cpp              | 68 ++++++++++----------
 robot_model/src/floating_joint_model.cpp           |  2 +-
 robot_model/src/joint_model_group.cpp              | 22 +++----
 robot_model/src/robot_model.cpp                    | 72 +++++++++++-----------
 robot_state/src/conversions.cpp                    | 38 ++++++------
 robot_state/src/robot_state.cpp                    | 68 ++++++++++----------
 robot_trajectory/src/robot_trajectory.cpp          |  2 +-
 .../src/iterative_time_parameterization.cpp        | 26 ++++----
 transforms/src/transforms.cpp                      | 12 ++--
 34 files changed, 313 insertions(+), 313 deletions(-)

diff --git a/background_processing/src/background_processing.cpp b/background_processing/src/background_processing.cpp
index 1f3630b..fc3335f 100644
--- a/background_processing/src/background_processing.cpp
+++ b/background_processing/src/background_processing.cpp
@@ -73,13 +73,13 @@ void moveit::tools::BackgroundProcessing::processingThread()
       action_lock_.unlock();
       try
       {
-        logDebug("moveit.background: Begin executing '%s'", action_name.c_str());
+        CONSOLE_BRIDGE_logDebug("moveit.background: Begin executing '%s'", action_name.c_str());
         fn();
-        logDebug("moveit.background: Done executing '%s'", action_name.c_str());
+        CONSOLE_BRIDGE_logDebug("moveit.background: Done executing '%s'", action_name.c_str());
       }
       catch (std::exception& ex)
       {
-        logError("Exception caught while processing action '%s': %s", action_name.c_str(), ex.what());
+        CONSOLE_BRIDGE_logError("Exception caught while processing action '%s': %s", action_name.c_str(), ex.what());
       }
       processing_ = false;
       if (queue_change_event_)
diff --git a/collision_detection/src/collision_matrix.cpp b/collision_detection/src/collision_matrix.cpp
index 830c728..421906c 100644
--- a/collision_detection/src/collision_matrix.cpp
+++ b/collision_detection/src/collision_matrix.cpp
@@ -53,12 +53,12 @@ collision_detection::AllowedCollisionMatrix::AllowedCollisionMatrix(const moveit
 {
   if (msg.entry_names.size() != msg.entry_values.size() ||
       msg.default_entry_names.size() != msg.default_entry_values.size())
-    logError("The number of links does not match the number of entries in AllowedCollisionMatrix message");
+    CONSOLE_BRIDGE_logError("The number of links does not match the number of entries in AllowedCollisionMatrix message");
   else
   {
     for (std::size_t i = 0; i < msg.entry_names.size(); ++i)
       if (msg.entry_values[i].enabled.size() != msg.entry_names.size())
-        logError("Number of entries is incorrect for link '%s' in AllowedCollisionMatrix message",
+        CONSOLE_BRIDGE_logError("Number of entries is incorrect for link '%s' in AllowedCollisionMatrix message",
                  msg.entry_names[i].c_str());
       else
         for (std::size_t j = i + 1; j < msg.entry_values[i].enabled.size(); ++j)
diff --git a/collision_detection/src/collision_octomap_filter.cpp b/collision_detection/src/collision_octomap_filter.cpp
index ffeab14..1ea0743 100644
--- a/collision_detection/src/collision_octomap_filter.cpp
+++ b/collision_detection/src/collision_octomap_filter.cpp
@@ -64,12 +64,12 @@ int collision_detection::refineContactNormals(const World::ObjectConstPtr& objec
 {
   if (!object)
   {
-    logError("No valid Object passed in, cannot refine Normals!");
+    CONSOLE_BRIDGE_logError("No valid Object passed in, cannot refine Normals!");
     return 0;
   }
   if (res.contact_count < 1)
   {
-    logWarn("There do not appear to be any contacts, so there is nothing to refine!");
+    CONSOLE_BRIDGE_logWarn("There do not appear to be any contacts, so there is nothing to refine!");
     return 0;
   }
 
@@ -133,7 +133,7 @@ int collision_detection::refineContactNormals(const World::ObjectConstPtr& objec
           //          contact_point.x(), contact_point.y(), contact_point.z(), cell_size, count);
 
           // octree->getOccupiedLeafsBBX(node_centers, bbx_min, bbx_max);
-          // logError("bad stuff in collision_octomap_filter.cpp; need to port octomap call for groovy");
+          // CONSOLE_BRIDGE_logError("bad stuff in collision_octomap_filter.cpp; need to port octomap call for groovy");
 
           octomath::Vector3 n;
           double depth;
@@ -267,7 +267,7 @@ bool sampleCloud(const octomap::point3d_list& cloud, const double& spacing, cons
     }
     else
     {
-      logError("This should not be called!");
+      CONSOLE_BRIDGE_logError("This should not be called!");
     }
 
     double f_val = 0;
@@ -293,7 +293,7 @@ bool sampleCloud(const octomap::point3d_list& cloud, const double& spacing, cons
     }
     else
     {
-      logError("This should not be called!");
+      CONSOLE_BRIDGE_logError("This should not be called!");
       double r_scaled = r / R;
       // TODO still need to address the scaling...
       f_val = pow((1 - r_scaled), 4) * (4 * r_scaled + 1);
diff --git a/collision_detection/src/collision_robot.cpp b/collision_detection/src/collision_robot.cpp
index 5200709..2d59dde 100644
--- a/collision_detection/src/collision_robot.cpp
+++ b/collision_detection/src/collision_robot.cpp
@@ -41,12 +41,12 @@ static inline bool validateScale(double scale)
 {
   if (scale < std::numeric_limits<double>::epsilon())
   {
-    logError("Scale must be positive");
+    CONSOLE_BRIDGE_logError("Scale must be positive");
     return false;
   }
   if (scale > std::numeric_limits<double>::max())
   {
-    logError("Scale must be finite");
+    CONSOLE_BRIDGE_logError("Scale must be finite");
     return false;
   }
   return true;
@@ -56,12 +56,12 @@ static inline bool validatePadding(double padding)
 {
   if (padding < 0.0)
   {
-    logError("Padding cannot be negative");
+    CONSOLE_BRIDGE_logError("Padding cannot be negative");
     return false;
   }
   if (padding > std::numeric_limits<double>::max())
   {
-    logError("Padding must be finite");
+    CONSOLE_BRIDGE_logError("Padding must be finite");
     return false;
   }
   return true;
diff --git a/collision_detection/src/world.cpp b/collision_detection/src/world.cpp
index 7adf9b0..360a06a 100644
--- a/collision_detection/src/world.cpp
+++ b/collision_detection/src/world.cpp
@@ -64,7 +64,7 @@ void collision_detection::World::addToObject(const std::string& id, const std::v
 {
   if (shapes.size() != poses.size())
   {
-    logError("Number of shapes and number of poses do not match. Not adding this object to collision world.");
+    CONSOLE_BRIDGE_logError("Number of shapes and number of poses do not match. Not adding this object to collision world.");
     return;
   }
 
diff --git a/collision_detection_fcl/src/collision_common.cpp b/collision_detection_fcl/src/collision_common.cpp
index 2c4da7d..9f6d603 100644
--- a/collision_detection_fcl/src/collision_common.cpp
+++ b/collision_detection_fcl/src/collision_common.cpp
@@ -88,7 +88,7 @@ bool collisionCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
       {
         always_allow_collision = true;
         if (cdata->req_->verbose)
-          logDebug(
+          CONSOLE_BRIDGE_logDebug(
               "Collision between '%s' (type '%s') and '%s' (type '%s') is always allowed. No contacts are computed.",
               cd1->getID().c_str(), cd1->getTypeString().c_str(), cd2->getID().c_str(), cd2->getTypeString().c_str());
       }
@@ -96,7 +96,7 @@ bool collisionCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
       {
         cdata->acm_->getAllowedCollision(cd1->getID(), cd2->getID(), dcf);
         if (cdata->req_->verbose)
-          logDebug("Collision between '%s' and '%s' is conditionally allowed", cd1->getID().c_str(),
+          CONSOLE_BRIDGE_logDebug("Collision between '%s' and '%s' is conditionally allowed", cd1->getID().c_str(),
                    cd2->getID().c_str());
       }
     }
@@ -110,7 +110,7 @@ bool collisionCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
     {
       always_allow_collision = true;
       if (cdata->req_->verbose)
-        logDebug("Robot link '%s' is allowed to touch attached object '%s'. No contacts are computed.",
+        CONSOLE_BRIDGE_logDebug("Robot link '%s' is allowed to touch attached object '%s'. No contacts are computed.",
                  cd1->getID().c_str(), cd2->getID().c_str());
     }
   }
@@ -121,7 +121,7 @@ bool collisionCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
     {
       always_allow_collision = true;
       if (cdata->req_->verbose)
-        logDebug("Robot link '%s' is allowed to touch attached object '%s'. No contacts are computed.",
+        CONSOLE_BRIDGE_logDebug("Robot link '%s' is allowed to touch attached object '%s'. No contacts are computed.",
                  cd2->getID().c_str(), cd1->getID().c_str());
     }
   }
@@ -137,7 +137,7 @@ bool collisionCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
     return false;
 
   if (cdata->req_->verbose)
-    logDebug("Actually checking collisions between %s and %s", cd1->getID().c_str(), cd2->getID().c_str());
+    CONSOLE_BRIDGE_logDebug("Actually checking collisions between %s and %s", cd1->getID().c_str(), cd2->getID().c_str());
 
   // see if we need to compute a contact
   std::size_t want_contact_count = 0;
@@ -365,7 +365,7 @@ struct FCLShapeCache
           map_.erase(it);
         it = nit;
       }
-      //      logDebug("Cleaning up cache for FCL objects that correspond to static shapes. Cache size reduced from %u
+      //      CONSOLE_BRIDGE_logDebug("Cleaning up cache for FCL objects that correspond to static shapes. Cache size reduced from %u
       //      to %u", from, (unsigned int)map_.size());
     }
   }
@@ -423,7 +423,7 @@ bool distanceCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
       {
         always_allow_collision = true;
         if (cdata->req_->verbose)
-          logDebug("Collision between '%s' and '%s' is always allowed. No distances are computed.",
+          CONSOLE_BRIDGE_logDebug("Collision between '%s' and '%s' is always allowed. No distances are computed.",
                    cd1->getID().c_str(), cd2->getID().c_str());
       }
     }
@@ -437,7 +437,7 @@ bool distanceCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
     {
       always_allow_collision = true;
       if (cdata->req_->verbose)
-        logDebug("Robot link '%s' is allowed to touch attached object '%s'. No distances are computed.",
+        CONSOLE_BRIDGE_logDebug("Robot link '%s' is allowed to touch attached object '%s'. No distances are computed.",
                  cd1->getID().c_str(), cd2->getID().c_str());
     }
   }
@@ -450,7 +450,7 @@ bool distanceCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
       {
         always_allow_collision = true;
         if (cdata->req_->verbose)
-          logDebug("Robot link '%s' is allowed to touch attached object '%s'. No distances are computed.",
+          CONSOLE_BRIDGE_logDebug("Robot link '%s' is allowed to touch attached object '%s'. No distances are computed.",
                    cd2->getID().c_str(), cd1->getID().c_str());
       }
     }
@@ -468,7 +468,7 @@ bool distanceCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
   const double d = fcl::distance(o1, o2, fcl::DistanceRequest(), dist_result);
 
   if (cdata->req_->verbose)
-    logDebug("Distance between %s and %s: %f", cd1->getID().c_str(), cd2->getID().c_str(), d);
+    CONSOLE_BRIDGE_logDebug("Distance between %s and %s: %f", cd1->getID().c_str(), cd2->getID().c_str(), d);
 
   if (d < 0)  // a penetration was found, no further distance calculations are necessary
   {
@@ -480,7 +480,7 @@ bool distanceCallback(fcl::CollisionObject* o1, fcl::CollisionObject* o2, void*
     if (cdata->res_->distance > d)
     {
       if (cdata->req_->verbose)
-        logWarn("Distance between %s and %s: %f decreased", cd1->getID().c_str(), cd2->getID().c_str(), d);
+        CONSOLE_BRIDGE_logWarn("Distance between %s and %s: %f decreased", cd1->getID().c_str(), cd2->getID().c_str(), d);
       cdata->res_->distance = d;
     }
   }
@@ -532,14 +532,14 @@ FCLGeometryConstPtr createCollisionGeometry(const shapes::ShapeConstPtr& shape,
     {
       if (cache_it->second->collision_geometry_data_->ptr.raw == (void*)data)
       {
-        //        logDebug("Collision data structures for object %s retrieved from cache.",
+        //        CONSOLE_BRIDGE_logDebug("Collision data structures for object %s retrieved from cache.",
         //        cache_it->second->collision_geometry_data_->getID().c_str());
         return cache_it->second;
       }
       else if (cache_it->second.unique())
       {
         const_cast<FCLGeometry*>(cache_it->second.get())->updateCollisionGeometryData(data, shape_index, false);
-        //          logDebug("Collision data structures for object %s retrieved from cache after updating the source
+        //          CONSOLE_BRIDGE_logDebug("Collision data structures for object %s retrieved from cache after updating the source
         //          object.", cache_it->second->collision_geometry_data_->getID().c_str());
         return cache_it->second;
       }
@@ -569,7 +569,7 @@ FCLGeometryConstPtr createCollisionGeometry(const shapes::ShapeConstPtr& shape,
         // update the CollisionGeometryData; nobody has a pointer to this, so we can safely modify it
         const_cast<FCLGeometry*>(obj_cache.get())->updateCollisionGeometryData(data, shape_index, true);
 
-        //        logDebug("Collision data structures for attached body %s retrieved from the cache for world objects.",
+        //        CONSOLE_BRIDGE_logDebug("Collision data structures for attached body %s retrieved from the cache for world objects.",
         //        obj_cache->collision_geometry_data_->getID().c_str());
 
         // add to the new cache
@@ -605,7 +605,7 @@ FCLGeometryConstPtr createCollisionGeometry(const shapes::ShapeConstPtr& shape,
         // update the CollisionGeometryData; nobody has a pointer to this, so we can safely modify it
         const_cast<FCLGeometry*>(obj_cache.get())->updateCollisionGeometryData(data, shape_index, true);
 
-        //          logDebug("Collision data structures for world object %s retrieved from the cache for attached
+        //          CONSOLE_BRIDGE_logDebug("Collision data structures for world object %s retrieved from the cache for attached
         //          bodies.",
         //                   obj_cache->collision_geometry_data_->getID().c_str());
 
@@ -693,7 +693,7 @@ FCLGeometryConstPtr createCollisionGeometry(const shapes::ShapeConstPtr& shape,
       }
       break;
       default:
-        logError("This shape type (%d) is not supported using FCL yet", (int)shape->type);
+        CONSOLE_BRIDGE_logError("This shape type (%d) is not supported using FCL yet", (int)shape->type);
         cg_g = NULL;
     }
   }
diff --git a/collision_detection_fcl/src/collision_robot_fcl.cpp b/collision_detection_fcl/src/collision_robot_fcl.cpp
index a5d7b13..f4b9c9a 100644
--- a/collision_detection_fcl/src/collision_robot_fcl.cpp
+++ b/collision_detection_fcl/src/collision_robot_fcl.cpp
@@ -62,7 +62,7 @@ collision_detection::CollisionRobotFCL::CollisionRobotFCL(const robot_model::Rob
         fcl_objs_[index] = FCLCollisionObjectConstPtr(new fcl::CollisionObject(g->collision_geometry_));
       }
       else
-        logError("Unable to construct collision geometry for link '%s'", links[i]->getName().c_str());
+        CONSOLE_BRIDGE_logError("Unable to construct collision geometry for link '%s'", links[i]->getName().c_str());
     }
 }
 
@@ -151,7 +151,7 @@ void collision_detection::CollisionRobotFCL::checkSelfCollision(const CollisionR
                                                                 const robot_state::RobotState& state1,
                                                                 const robot_state::RobotState& state2) const
 {
-  logError("FCL continuous collision checking not yet implemented");
+  CONSOLE_BRIDGE_logError("FCL continuous collision checking not yet implemented");
 }
 
 void collision_detection::CollisionRobotFCL::checkSelfCollision(const CollisionRequest& req, CollisionResult& res,
@@ -159,7 +159,7 @@ void collision_detection::CollisionRobotFCL::checkSelfCollision(const CollisionR
                                                                 const robot_state::RobotState& state2,
                                                                 const AllowedCollisionMatrix& acm) const
 {
-  logError("FCL continuous collision checking not yet implemented");
+  CONSOLE_BRIDGE_logError("FCL continuous collision checking not yet implemented");
 }
 
 void collision_detection::CollisionRobotFCL::checkSelfCollisionHelper(const CollisionRequest& req, CollisionResult& res,
@@ -199,7 +199,7 @@ void collision_detection::CollisionRobotFCL::checkOtherCollision(const Collision
                                                                  const robot_state::RobotState& other_state1,
                                                                  const robot_state::RobotState& other_state2) const
 {
-  logError("FCL continuous collision checking not yet implemented");
+  CONSOLE_BRIDGE_logError("FCL continuous collision checking not yet implemented");
 }
 
 void collision_detection::CollisionRobotFCL::checkOtherCollision(const CollisionRequest& req, CollisionResult& res,
@@ -210,7 +210,7 @@ void collision_detection::CollisionRobotFCL::checkOtherCollision(const Collision
                                                                  const robot_state::RobotState& other_state2,
                                                                  const AllowedCollisionMatrix& acm) const
 {
-  logError("FCL continuous collision checking not yet implemented");
+  CONSOLE_BRIDGE_logError("FCL continuous collision checking not yet implemented");
 }
 
 void collision_detection::CollisionRobotFCL::checkOtherCollisionHelper(const CollisionRequest& req,
@@ -256,7 +256,7 @@ void collision_detection::CollisionRobotFCL::updatedPaddingOrScaling(const std::
       }
     }
     else
-      logError("Updating padding or scaling for unknown link: '%s'", links[i].c_str());
+      CONSOLE_BRIDGE_logError("Updating padding or scaling for unknown link: '%s'", links[i].c_str());
   }
 }
 
diff --git a/collision_detection_fcl/src/collision_world_fcl.cpp b/collision_detection_fcl/src/collision_world_fcl.cpp
index f53e2cc..9870d4f 100644
--- a/collision_detection_fcl/src/collision_world_fcl.cpp
+++ b/collision_detection_fcl/src/collision_world_fcl.cpp
@@ -103,7 +103,7 @@ void collision_detection::CollisionWorldFCL::checkRobotCollision(const Collision
                                                                  const robot_state::RobotState& state1,
                                                                  const robot_state::RobotState& state2) const
 {
-  logError("FCL continuous collision checking not yet implemented");
+  CONSOLE_BRIDGE_logError("FCL continuous collision checking not yet implemented");
 }
 
 void collision_detection::CollisionWorldFCL::checkRobotCollision(const CollisionRequest& req, CollisionResult& res,
@@ -112,7 +112,7 @@ void collision_detection::CollisionWorldFCL::checkRobotCollision(const Collision
                                                                  const robot_state::RobotState& state2,
                                                                  const AllowedCollisionMatrix& acm) const
 {
-  logError("FCL continuous collision checking not yet implemented");
+  CONSOLE_BRIDGE_logError("FCL continuous collision checking not yet implemented");
 }
 
 void collision_detection::CollisionWorldFCL::checkRobotCollisionHelper(const CollisionRequest& req,
diff --git a/constraint_samplers/src/constraint_sampler.cpp b/constraint_samplers/src/constraint_sampler.cpp
index 51e93d3..c44ef88 100644
--- a/constraint_samplers/src/constraint_sampler.cpp
+++ b/constraint_samplers/src/constraint_sampler.cpp
@@ -43,7 +43,7 @@ constraint_samplers::ConstraintSampler::ConstraintSampler(const planning_scene::
   jmg_ = scene->getRobotModel()->getJointModelGroup(group_name);
   if (!jmg_)
   {
-    logError("A JointModelGroup should have been specified for the constraint sampler");
+    CONSOLE_BRIDGE_logError("A JointModelGroup should have been specified for the constraint sampler");
   }
 }
 
diff --git a/constraint_samplers/src/constraint_sampler_manager.cpp b/constraint_samplers/src/constraint_sampler_manager.cpp
index 00e394d..faf42ab 100644
--- a/constraint_samplers/src/constraint_sampler_manager.cpp
+++ b/constraint_samplers/src/constraint_sampler_manager.cpp
@@ -60,14 +60,14 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
     return constraint_samplers::ConstraintSamplerPtr();
   std::stringstream ss;
   ss << constr;
-  logDebug("Attempting to construct constrained state sampler for group '%s', using constraints:\n%s.\n",
+  CONSOLE_BRIDGE_logDebug("Attempting to construct constrained state sampler for group '%s', using constraints:\n%s.\n",
            jmg->getName().c_str(), ss.str().c_str());
 
   ConstraintSamplerPtr joint_sampler;  // location to put chosen joint sampler if needed
   // if there are joint constraints, we could possibly get a sampler from those
   if (!constr.joint_constraints.empty())
   {
-    logDebug("There are joint constraints specified. Attempting to construct a JointConstraintSampler for group '%s'",
+    CONSOLE_BRIDGE_logDebug("There are joint constraints specified. Attempting to construct a JointConstraintSampler for group '%s'",
              jmg->getName().c_str());
 
     std::map<std::string, bool> joint_coverage;
@@ -104,7 +104,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
       JointConstraintSamplerPtr sampler(new JointConstraintSampler(scene, jmg->getName()));
       if (sampler->configure(jc))
       {
-        logDebug("Allocated a sampler satisfying joint constraints for group '%s'", jmg->getName().c_str());
+        CONSOLE_BRIDGE_logDebug("Allocated a sampler satisfying joint constraints for group '%s'", jmg->getName().c_str());
         return sampler;
       }
     }
@@ -116,7 +116,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
       JointConstraintSamplerPtr sampler(new JointConstraintSampler(scene, jmg->getName()));
       if (sampler->configure(jc))
       {
-        logDebug("Temporary sampler satisfying joint constraints for group '%s' allocated. Looking for different types "
+        CONSOLE_BRIDGE_logDebug("Temporary sampler satisfying joint constraints for group '%s' allocated. Looking for different types "
                  "of constraints before returning though.",
                  jmg->getName().c_str());
         joint_sampler = sampler;
@@ -136,7 +136,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
   // should be used
   if (ik_alloc)
   {
-    logDebug("There is an IK allocator for '%s'. Checking for corresponding position and/or orientation constraints",
+    CONSOLE_BRIDGE_logDebug("There is an IK allocator for '%s'. Checking for corresponding position and/or orientation constraints",
              jmg->getName().c_str());
 
     // keep track of which links we constrained
@@ -170,7 +170,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
               {
                 // assign the link to a new constraint sampler
                 usedL[constr.position_constraints[p].link_name] = iks;
-                logDebug("Allocated an IK-based sampler for group '%s' satisfying position and orientation constraints "
+                CONSOLE_BRIDGE_logDebug("Allocated an IK-based sampler for group '%s' satisfying position and orientation constraints "
                          "on link '%s'",
                          jmg->getName().c_str(), constr.position_constraints[p].link_name.c_str());
               }
@@ -202,7 +202,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
           if (use)
           {
             usedL[constr.position_constraints[p].link_name] = iks;
-            logDebug("Allocated an IK-based sampler for group '%s' satisfying position constraints on link '%s'",
+            CONSOLE_BRIDGE_logDebug("Allocated an IK-based sampler for group '%s' satisfying position constraints on link '%s'",
                      jmg->getName().c_str(), constr.position_constraints[p].link_name.c_str());
           }
         }
@@ -230,7 +230,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
           if (use)
           {
             usedL[constr.orientation_constraints[o].link_name] = iks;
-            logDebug("Allocated an IK-based sampler for group '%s' satisfying orientation constraints on link '%s'",
+            CONSOLE_BRIDGE_logDebug("Allocated an IK-based sampler for group '%s' satisfying orientation constraints on link '%s'",
                      jmg->getName().c_str(), constr.orientation_constraints[o].link_name.c_str());
           }
         }
@@ -249,7 +249,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
     }
     else if (usedL.size() > 1)
     {
-      logDebug("Too many IK-based samplers for group '%s'. Keeping the one with minimal sampling volume",
+      CONSOLE_BRIDGE_logDebug("Too many IK-based samplers for group '%s'. Keeping the one with minimal sampling volume",
                jmg->getName().c_str());
       // find the sampler with the smallest sampling volume; delete the rest
       IKConstraintSamplerPtr iks = usedL.begin()->second;
@@ -279,7 +279,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
   // we now check to see if we can use samplers from subgroups
   if (!ik_subgroup_alloc.empty())
   {
-    logDebug("There are IK allocators for subgroups of group '%s'. Checking for corresponding position and/or "
+    CONSOLE_BRIDGE_logDebug("There are IK allocators for subgroups of group '%s'. Checking for corresponding position and/or "
              "orientation constraints",
              jmg->getName().c_str());
 
@@ -310,12 +310,12 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
       // if some matching constraints were found, construct the allocator
       if (!sub_constr.orientation_constraints.empty() || !sub_constr.position_constraints.empty())
       {
-        logDebug("Attempting to construct a sampler for the '%s' subgroup of '%s'", it->first->getName().c_str(),
+        CONSOLE_BRIDGE_logDebug("Attempting to construct a sampler for the '%s' subgroup of '%s'", it->first->getName().c_str(),
                  jmg->getName().c_str());
         ConstraintSamplerPtr cs = selectDefaultSampler(scene, it->first->getName(), sub_constr);
         if (cs)
         {
-          logDebug("Constructed a sampler for the joints corresponding to group '%s', but part of group '%s'",
+          CONSOLE_BRIDGE_logDebug("Constructed a sampler for the joints corresponding to group '%s', but part of group '%s'",
                    it->first->getName().c_str(), jmg->getName().c_str());
           some_sampler_valid = true;
           samplers.push_back(cs);
@@ -324,7 +324,7 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
     }
     if (some_sampler_valid)
     {
-      logDebug("Constructing sampler for group '%s' as a union of %u samplers", jmg->getName().c_str(),
+      CONSOLE_BRIDGE_logDebug("Constructing sampler for group '%s' as a union of %u samplers", jmg->getName().c_str(),
                (unsigned int)samplers.size());
       return ConstraintSamplerPtr(new UnionConstraintSampler(scene, jmg->getName(), samplers));
     }
@@ -333,11 +333,11 @@ constraint_samplers::ConstraintSamplerPtr constraint_samplers::ConstraintSampler
   // if we've gotten here, just return joint sampler
   if (joint_sampler)
   {
-    logDebug("Allocated a sampler satisfying joint constraints for group '%s'", jmg->getName().c_str());
+    CONSOLE_BRIDGE_logDebug("Allocated a sampler satisfying joint constraints for group '%s'", jmg->getName().c_str());
     return joint_sampler;
   }
 
-  logDebug("No constraints sampler allocated for group '%s'", jmg->getName().c_str());
+  CONSOLE_BRIDGE_logDebug("No constraints sampler allocated for group '%s'", jmg->getName().c_str());
 
   return ConstraintSamplerPtr();
 }
diff --git a/constraint_samplers/src/constraint_sampler_tools.cpp b/constraint_samplers/src/constraint_sampler_tools.cpp
index bad97fb..b212211 100644
--- a/constraint_samplers/src/constraint_sampler_tools.cpp
+++ b/constraint_samplers/src/constraint_sampler_tools.cpp
@@ -59,7 +59,7 @@ double constraint_samplers::countSamplesPerSecond(const ConstraintSamplerPtr& sa
 {
   if (!sampler)
   {
-    logError("No sampler specified for counting samples per second");
+    CONSOLE_BRIDGE_logError("No sampler specified for counting samples per second");
     return 0.0;
   }
   robot_state::RobotState ks(reference_state);
@@ -86,7 +86,7 @@ void constraint_samplers::visualizeDistribution(const ConstraintSamplerPtr& samp
 {
   if (!sampler)
   {
-    logError("No sampler specified for visualizing distribution of samples");
+    CONSOLE_BRIDGE_logError("No sampler specified for visualizing distribution of samples");
     return;
   }
   const robot_state::LinkModel* lm = reference_state.getLinkModel(link_name);
diff --git a/constraint_samplers/src/default_constraint_samplers.cpp b/constraint_samplers/src/default_constraint_samplers.cpp
index a085912..deeb14e 100644
--- a/constraint_samplers/src/default_constraint_samplers.cpp
+++ b/constraint_samplers/src/default_constraint_samplers.cpp
@@ -61,7 +61,7 @@ bool constraint_samplers::JointConstraintSampler::configure(
 
   if (!jmg_)
   {
-    logError("NULL group specified for constraint sampler");
+    CONSOLE_BRIDGE_logError("NULL group specified for constraint sampler");
     return false;
   }
 
@@ -91,14 +91,14 @@ bool constraint_samplers::JointConstraintSampler::configure(
         std::max(joint_bounds.min_position_, jc[i].getDesiredJointPosition() - jc[i].getJointToleranceBelow()),
         std::min(joint_bounds.max_position_, jc[i].getDesiredJointPosition() + jc[i].getJointToleranceAbove()));
 
-    logDebug("Bounds for %s JointConstraint are %g %g", jc[i].getJointVariableName().c_str(), ji.min_bound_,
+    CONSOLE_BRIDGE_logDebug("Bounds for %s JointConstraint are %g %g", jc[i].getJointVariableName().c_str(), ji.min_bound_,
              ji.max_bound_);
 
     if (ji.min_bound_ > ji.max_bound_ + std::numeric_limits<double>::epsilon())
     {
       std::stringstream cs;
       jc[i].print(cs);
-      logError("The constraints for joint '%s' are such that there are no possible values for the joint: min_bound: "
+      CONSOLE_BRIDGE_logError("The constraints for joint '%s' are such that there are no possible values for the joint: min_bound: "
                "%g, max_bound: %g. Failing.\n",
                jm->getName().c_str(), ji.min_bound_, ji.max_bound_);
       clear();
@@ -109,7 +109,7 @@ bool constraint_samplers::JointConstraintSampler::configure(
 
   if (!some_valid_constraint)
   {
-    logWarn("No valid joint constraints");
+    CONSOLE_BRIDGE_logWarn("No valid joint constraints");
     return false;
   }
 
@@ -151,7 +151,7 @@ bool constraint_samplers::JointConstraintSampler::sample(robot_state::RobotState
 {
   if (!is_valid_)
   {
-    logWarn("JointConstraintSampler not configured, won't sample");
+    CONSOLE_BRIDGE_logWarn("JointConstraintSampler not configured, won't sample");
     return false;
   }
 
@@ -246,7 +246,7 @@ bool constraint_samplers::IKConstraintSampler::configure(const IKSamplingPose& s
       (sp.position_constraint_ && sp.orientation_constraint_ && !sp.position_constraint_->enabled() &&
        !sp.orientation_constraint_->enabled()))
   {
-    logWarn("No enabled constraints in sampling pose");
+    CONSOLE_BRIDGE_logWarn("No enabled constraints in sampling pose");
     return false;
   }
 
@@ -256,7 +256,7 @@ bool constraint_samplers::IKConstraintSampler::configure(const IKSamplingPose& s
     if (sampling_pose_.position_constraint_->getLinkModel()->getName() !=
         sampling_pose_.orientation_constraint_->getLinkModel()->getName())
     {
-      logError("Position and orientation constraints need to be specified for the same link in order to use IK-based "
+      CONSOLE_BRIDGE_logError("Position and orientation constraints need to be specified for the same link in order to use IK-based "
                "sampling");
       return false;
     }
@@ -268,7 +268,7 @@ bool constraint_samplers::IKConstraintSampler::configure(const IKSamplingPose& s
   kb_ = jmg_->getSolverInstance();
   if (!kb_)
   {
-    logWarn("No solver instance in setup");
+    CONSOLE_BRIDGE_logWarn("No solver instance in setup");
     is_valid_ = false;
     return false;
   }
@@ -340,7 +340,7 @@ bool constraint_samplers::IKConstraintSampler::loadIKSolver()
 {
   if (!kb_)
   {
-    logError("No IK solver");
+    CONSOLE_BRIDGE_logError("No IK solver");
     return false;
   }
 
@@ -352,7 +352,7 @@ bool constraint_samplers::IKConstraintSampler::loadIKSolver()
   if (transform_ik_)
     if (!jmg_->getParentModel().hasLinkModel(ik_frame_))
     {
-      logError("The IK solver expects requests in frame '%s' but this frame is not known to the sampler. Ignoring "
+      CONSOLE_BRIDGE_logError("The IK solver expects requests in frame '%s' but this frame is not known to the sampler. Ignoring "
                "transformation (IK may fail)",
                ik_frame_.c_str());
       transform_ik_ = false;
@@ -398,7 +398,7 @@ bool constraint_samplers::IKConstraintSampler::loadIKSolver()
 
   if (wrong_link)
   {
-    logError("IK cannot be performed for link '%s'. The solver can report IK solutions for link '%s'.",
+    CONSOLE_BRIDGE_logError("IK cannot be performed for link '%s'. The solver can report IK solutions for link '%s'.",
              sampling_pose_.position_constraint_ ?
                  sampling_pose_.position_constraint_->getLinkModel()->getName().c_str() :
                  sampling_pose_.orientation_constraint_->getLinkModel()->getName().c_str(),
@@ -414,7 +414,7 @@ bool constraint_samplers::IKConstraintSampler::samplePose(Eigen::Vector3d& pos,
   if (ks.dirtyLinkTransforms())
   {
     // samplePose below requires accurate transforms
-    logError("IKConstraintSampler received dirty robot state, but valid transforms are required. Failing.");
+    CONSOLE_BRIDGE_logError("IKConstraintSampler received dirty robot state, but valid transforms are required. Failing.");
     return false;
   }
 
@@ -433,13 +433,13 @@ bool constraint_samplers::IKConstraintSampler::samplePose(Eigen::Vector3d& pos,
         }
       if (!found)
       {
-        logError("Unable to sample a point inside the constraint region");
+        CONSOLE_BRIDGE_logError("Unable to sample a point inside the constraint region");
         return false;
       }
     }
     else
     {
-      logError("Unable to sample a point inside the constraint region. Constraint region is empty when it should not "
+      CONSOLE_BRIDGE_logError("Unable to sample a point inside the constraint region. Constraint region is empty when it should not "
                "be.");
       return false;
     }
@@ -534,7 +534,7 @@ bool constraint_samplers::IKConstraintSampler::sampleHelper(robot_state::RobotSt
 {
   if (!is_valid_)
   {
-    logWarn("IKConstraintSampler not configured, won't sample");
+    CONSOLE_BRIDGE_logWarn("IKConstraintSampler not configured, won't sample");
     return false;
   }
 
@@ -642,7 +642,7 @@ bool constraint_samplers::IKConstraintSampler::callIK(
     if (error.val != moveit_msgs::MoveItErrorCodes::NO_IK_SOLUTION &&
         error.val != moveit_msgs::MoveItErrorCodes::INVALID_ROBOT_STATE &&
         error.val != moveit_msgs::MoveItErrorCodes::TIMED_OUT)
-      logError("IK solver failed with error %d", error.val);
+      CONSOLE_BRIDGE_logError("IK solver failed with error %d", error.val);
     else if (verbose_)
       logInform("IK failed");
   }
diff --git a/constraint_samplers/src/union_constraint_sampler.cpp b/constraint_samplers/src/union_constraint_sampler.cpp
index b6766f4..783610f 100644
--- a/constraint_samplers/src/union_constraint_sampler.cpp
+++ b/constraint_samplers/src/union_constraint_sampler.cpp
@@ -80,7 +80,7 @@ struct OrderSamplers
         }
     if (b_depends_on_a && a_depends_on_b)
     {
-      logWarn("Circular frame dependency! Sampling will likely produce invalid results (sampling for groups '%s' and "
+      CONSOLE_BRIDGE_logWarn("Circular frame dependency! Sampling will likely produce invalid results (sampling for groups '%s' and "
               "'%s')",
               a->getJointModelGroup()->getName().c_str(), b->getJointModelGroup()->getName().c_str());
       return true;
@@ -118,7 +118,7 @@ constraint_samplers::UnionConstraintSampler::UnionConstraintSampler(const planni
     for (std::size_t j = 0; j < fd.size(); ++j)
       frame_depends_.push_back(fd[j]);
 
-    logDebug("Union sampler for group '%s' includes sampler for group '%s'", jmg_->getName().c_str(),
+    CONSOLE_BRIDGE_logDebug("Union sampler for group '%s' includes sampler for group '%s'", jmg_->getName().c_str(),
              samplers_[i]->getJointModelGroup()->getName().c_str());
   }
 }
diff --git a/constraint_samplers/test/pr2_arm_ik.cpp b/constraint_samplers/test/pr2_arm_ik.cpp
index 9043699..62e0183 100644
--- a/constraint_samplers/test/pr2_arm_ik.cpp
+++ b/constraint_samplers/test/pr2_arm_ik.cpp
@@ -67,9 +67,9 @@ bool PR2ArmIK::init(const urdf::ModelInterface& robot_model, const std::string&
     if (!joint)
     {
       if (link->parent_joint)
-        logError("Could not find joint: %s", link->parent_joint->name.c_str());
+        CONSOLE_BRIDGE_logError("Could not find joint: %s", link->parent_joint->name.c_str());
       else
-        logError("Link %s has no parent joint", link->name.c_str());
+        CONSOLE_BRIDGE_logError("Link %s has no parent joint", link->name.c_str());
       return false;
     }
     if (joint->type != urdf::Joint::UNKNOWN && joint->type != urdf::Joint::FIXED)
@@ -77,7 +77,7 @@ bool PR2ArmIK::init(const urdf::ModelInterface& robot_model, const std::string&
       link_offset.push_back(link->parent_joint->parent_to_joint_origin_transform);
       angle_multipliers_.push_back(joint->axis.x * fabs(joint->axis.x) + joint->axis.y * fabs(joint->axis.y) +
                                    joint->axis.z * fabs(joint->axis.z));
-      logDebug("Joint axis: %d, %f, %f, %f", 6 - num_joints, joint->axis.x, joint->axis.y, joint->axis.z);
+      CONSOLE_BRIDGE_logDebug("Joint axis: %d, %f, %f, %f", 6 - num_joints, joint->axis.x, joint->axis.y, joint->axis.z);
       if (joint->type != urdf::Joint::CONTINUOUS)
       {
         if (joint->safety)
@@ -96,7 +96,7 @@ bool PR2ArmIK::init(const urdf::ModelInterface& robot_model, const std::string&
           {
             min_angles_.push_back(0.0);
             max_angles_.push_back(0.0);
-            logWarn("No joint limits or joint '%s'", joint->name.c_str());
+            CONSOLE_BRIDGE_logWarn("No joint limits or joint '%s'", joint->name.c_str());
           }
         }
         continuous_joint_.push_back(false);
@@ -128,7 +128,7 @@ bool PR2ArmIK::init(const urdf::ModelInterface& robot_model, const std::string&
 
   if (num_joints != 7)
   {
-    logError("PR2ArmIK:: Chain from %s to %s does not have 7 joints", root_name.c_str(), tip_name.c_str());
+    CONSOLE_BRIDGE_logError("PR2ArmIK:: Chain from %s to %s does not have 7 joints", root_name.c_str(), tip_name.c_str());
     return false;
   }
 
diff --git a/distance_field/src/distance_field.cpp b/distance_field/src/distance_field.cpp
index 3f41496..f5a61c1 100644
--- a/distance_field/src/distance_field.cpp
+++ b/distance_field/src/distance_field.cpp
@@ -203,7 +203,7 @@ bool distance_field::DistanceField::getShapePoints(const shapes::Shape* shape, c
     const shapes::OcTree* oc = dynamic_cast<const shapes::OcTree*>(shape);
     if (!oc)
     {
-      logError("Problem dynamic casting shape that claims to be OcTree");
+      CONSOLE_BRIDGE_logError("Problem dynamic casting shape that claims to be OcTree");
       return false;
     }
     getOcTreePoints(oc->octree.get(), points);
@@ -291,7 +291,7 @@ void distance_field::DistanceField::moveShapeInField(const shapes::Shape* shape,
 {
   if (shape->type == shapes::OCTREE)
   {
-    logWarn("Move shape not supported for Octree");
+    CONSOLE_BRIDGE_logWarn("Move shape not supported for Octree");
     return;
   }
   bodies::Body* body = bodies::createBodyFromShape(shape);
diff --git a/distance_field/src/propagation_distance_field.cpp b/distance_field/src/propagation_distance_field.cpp
index 5bfeae8..3d5e273 100644
--- a/distance_field/src/propagation_distance_field.cpp
+++ b/distance_field/src/propagation_distance_field.cpp
@@ -101,26 +101,26 @@ int PropagationDistanceField::eucDistSq(Eigen::Vector3i point1, Eigen::Vector3i
 
 void PropagationDistanceField::print(const VoxelSet& set)
 {
-  logDebug("[");
+  CONSOLE_BRIDGE_logDebug("[");
   VoxelSet::const_iterator it;
   for (it = set.begin(); it != set.end(); ++it)
   {
     Eigen::Vector3i loc1 = *it;
-    logDebug("%d, %d, %d ", loc1.x(), loc1.y(), loc1.z());
+    CONSOLE_BRIDGE_logDebug("%d, %d, %d ", loc1.x(), loc1.y(), loc1.z());
   }
-  logDebug("] size=%u\n", (unsigned int)set.size());
+  CONSOLE_BRIDGE_logDebug("] size=%u\n", (unsigned int)set.size());
 }
 
 void PropagationDistanceField::print(const EigenSTL::vector_Vector3d& points)
 {
-  logDebug("[");
+  CONSOLE_BRIDGE_logDebug("[");
   EigenSTL::vector_Vector3d::const_iterator it;
   for (it = points.begin(); it != points.end(); ++it)
   {
     Eigen::Vector3d loc1 = *it;
-    logDebug("%g, %g, %g ", loc1.x(), loc1.y(), loc1.z());
+    CONSOLE_BRIDGE_logDebug("%g, %g, %g ", loc1.x(), loc1.y(), loc1.z());
   }
-  logDebug("] size=%u\n", (unsigned int)points.size());
+  CONSOLE_BRIDGE_logDebug("] size=%u\n", (unsigned int)points.size());
 }
 
 void PropagationDistanceField::updatePointsInField(const EigenSTL::vector_Vector3d& old_points,
@@ -172,13 +172,13 @@ void PropagationDistanceField::updatePointsInField(const EigenSTL::vector_Vector
   removeObstacleVoxels(old_not_new);
   addNewObstacleVoxels(new_not_in_current);
 
-  // logDebug( "new=" );
+  // CONSOLE_BRIDGE_logDebug( "new=" );
   // print(points_added);
-  // logDebug( "removed=" );
+  // CONSOLE_BRIDGE_logDebug( "removed=" );
   // print(points_removed);
-  // logDebug( "obstacle_voxel_locations_=" );
+  // CONSOLE_BRIDGE_logDebug( "obstacle_voxel_locations_=" );
   // print(object_voxel_locations_);
-  // logDebug("");
+  // CONSOLE_BRIDGE_logDebug("");
 }
 
 void PropagationDistanceField::addPointsToField(const EigenSTL::vector_Vector3d& points)
@@ -415,7 +415,7 @@ void PropagationDistanceField::propagatePositive()
       // This will never happen.  update_direction_ is always set before voxel is added to bucket queue.
       if (vptr->update_direction_ < 0 || vptr->update_direction_ > 26)
       {
-        logError("PROGRAMMING ERROR: Invalid update direction detected: %d", vptr->update_direction_);
+        CONSOLE_BRIDGE_logError("PROGRAMMING ERROR: Invalid update direction detected: %d", vptr->update_direction_);
         continue;
       }
 
@@ -473,7 +473,7 @@ void PropagationDistanceField::propagateNegative()
       // negative_bucket_queue_.
       if (vptr->negative_update_direction_ < 0 || vptr->negative_update_direction_ > 26)
       {
-        logError("PROGRAMMING ERROR: Invalid update direction detected: %d", vptr->update_direction_);
+        CONSOLE_BRIDGE_logError("PROGRAMMING ERROR: Invalid update direction detected: %d", vptr->update_direction_);
         continue;
       }
 
diff --git a/distance_field/test/test_distance_field.cpp b/distance_field/test/test_distance_field.cpp
index 04ee0da..b812391 100644
--- a/distance_field/test/test_distance_field.cpp
+++ b/distance_field/test/test_distance_field.cpp
@@ -767,7 +767,7 @@ TEST(TestSignedPropagationDistanceField, TestPerformance)
 
         if (!valid)
         {
-          logWarn("Something wrong");
+          CONSOLE_BRIDGE_logWarn("Something wrong");
           continue;
         }
         bad_vec.push_back(loc);
diff --git a/dynamics_solver/src/dynamics_solver.cpp b/dynamics_solver/src/dynamics_solver.cpp
index 3dea117..c89660f 100644
--- a/dynamics_solver/src/dynamics_solver.cpp
+++ b/dynamics_solver/src/dynamics_solver.cpp
@@ -74,7 +74,7 @@ DynamicsSolver::DynamicsSolver(const robot_model::RobotModelConstPtr& robot_mode
 
   if (!joint_model_group_->isChain())
   {
-    logError("moveit.dynamics_solver: Group '%s' is not a chain. Will not initialize dynamics solver",
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Group '%s' is not a chain. Will not initialize dynamics solver",
              group_name.c_str());
     joint_model_group_ = NULL;
     return;
@@ -82,7 +82,7 @@ DynamicsSolver::DynamicsSolver(const robot_model::RobotModelConstPtr& robot_mode
 
   if (joint_model_group_->getMimicJointModels().size() > 0)
   {
-    logError("moveit.dynamics_solver: Group '%s' has a mimic joint. Will not initialize dynamics solver",
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Group '%s' has a mimic joint. Will not initialize dynamics solver",
              group_name.c_str());
     joint_model_group_ = NULL;
     return;
@@ -91,7 +91,7 @@ DynamicsSolver::DynamicsSolver(const robot_model::RobotModelConstPtr& robot_mode
   const robot_model::JointModel* joint = joint_model_group_->getJointRoots()[0];
   if (!joint->getParentLinkModel())
   {
-    logError("moveit.dynamics_solver: Group '%s' does not have a parent link", group_name.c_str());
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Group '%s' does not have a parent link", group_name.c_str());
     joint_model_group_ = NULL;
     return;
   }
@@ -99,7 +99,7 @@ DynamicsSolver::DynamicsSolver(const robot_model::RobotModelConstPtr& robot_mode
   base_name_ = joint->getParentLinkModel()->getName();
 
   tip_name_ = joint_model_group_->getLinkModelNames().back();
-  logDebug("moveit.dynamics_solver: Base name: '%s', Tip name: '%s'", base_name_.c_str(), tip_name_.c_str());
+  CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Base name: '%s', Tip name: '%s'", base_name_.c_str(), tip_name_.c_str());
 
   const urdf::ModelInterfaceSharedPtr urdf_model = robot_model_->getURDF();
   const srdf::ModelConstSharedPtr srdf_model = robot_model_->getSRDF();
@@ -107,13 +107,13 @@ DynamicsSolver::DynamicsSolver(const robot_model::RobotModelConstPtr& robot_mode
 
   if (!kdl_parser::treeFromUrdfModel(*urdf_model, tree))
   {
-    logError("moveit.dynamics_solver: Could not initialize tree object");
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Could not initialize tree object");
     joint_model_group_ = NULL;
     return;
   }
   if (!tree.getChain(base_name_, tip_name_, kdl_chain_))
   {
-    logError("moveit.dynamics_solver: Could not initialize chain object");
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Could not initialize chain object");
     joint_model_group_ = NULL;
     return;
   }
@@ -136,7 +136,7 @@ DynamicsSolver::DynamicsSolver(const robot_model::RobotModelConstPtr& robot_mode
   KDL::Vector gravity(gravity_vector.x, gravity_vector.y,
                       gravity_vector.z);  // \todo Not sure if KDL expects the negative of this (Sachin)
   gravity_ = gravity.Norm();
-  logDebug("moveit.dynamics_solver: Gravity norm set to %f", gravity_);
+  CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Gravity norm set to %f", gravity_);
 
   chain_id_solver_.reset(new KDL::ChainIdSolver_RNE(kdl_chain_, gravity));
 }
@@ -147,32 +147,32 @@ bool DynamicsSolver::getTorques(const std::vector<double>& joint_angles, const s
 {
   if (!joint_model_group_)
   {
-    logDebug("moveit.dynamics_solver: Did not construct DynamicsSolver object properly. Check error logs.");
+    CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Did not construct DynamicsSolver object properly. Check error logs.");
     return false;
   }
   if (joint_angles.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Joint angles vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Joint angles vector should be size %d", num_joints_);
     return false;
   }
   if (joint_velocities.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Joint velocities vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Joint velocities vector should be size %d", num_joints_);
     return false;
   }
   if (joint_accelerations.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Joint accelerations vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Joint accelerations vector should be size %d", num_joints_);
     return false;
   }
   if (wrenches.size() != num_segments_)
   {
-    logError("moveit.dynamics_solver: Wrenches vector should be size %d", num_segments_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Wrenches vector should be size %d", num_segments_);
     return false;
   }
   if (torques.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Torques vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Torques vector should be size %d", num_joints_);
     return false;
   }
 
@@ -200,7 +200,7 @@ bool DynamicsSolver::getTorques(const std::vector<double>& joint_angles, const s
 
   if (chain_id_solver_->CartToJnt(kdl_angles, kdl_velocities, kdl_accelerations, kdl_wrenches, kdl_torques) < 0)
   {
-    logError("moveit.dynamics_solver: Something went wrong computing torques");
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Something went wrong computing torques");
     return false;
   }
 
@@ -215,12 +215,12 @@ bool DynamicsSolver::getMaxPayload(const std::vector<double>& joint_angles, doub
 {
   if (!joint_model_group_)
   {
-    logDebug("moveit.dynamics_solver: Did not construct DynamicsSolver object properly. Check error logs.");
+    CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Did not construct DynamicsSolver object properly. Check error logs.");
     return false;
   }
   if (joint_angles.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Joint angles vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Joint angles vector should be size %d", num_joints_);
     return false;
   }
   std::vector<double> joint_velocities(num_joints_, 0.0), joint_accelerations(num_joints_, 0.0);
@@ -248,7 +248,7 @@ bool DynamicsSolver::getMaxPayload(const std::vector<double>& joint_angles, doub
   wrenches.back().force = transformVector(transform, wrenches.back().force);
   wrenches.back().torque = transformVector(transform, wrenches.back().torque);
 
-  logDebug("moveit.dynamics_solver: New wrench (local frame): %f %f %f", wrenches.back().force.x,
+  CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: New wrench (local frame): %f %f %f", wrenches.back().force.x,
            wrenches.back().force.y, wrenches.back().force.z);
 
   if (!getTorques(joint_angles, joint_velocities, joint_accelerations, wrenches, torques))
@@ -260,9 +260,9 @@ bool DynamicsSolver::getMaxPayload(const std::vector<double>& joint_angles, doub
     double payload_joint = std::max<double>((max_torques_[i] - zero_torques[i]) / (torques[i] - zero_torques[i]),
                                             (-max_torques_[i] - zero_torques[i]) /
                                                 (torques[i] - zero_torques[i]));  // because we set the payload to 1.0
-    logDebug("moveit.dynamics_solver: Joint: %d, Actual Torque: %f, Max Allowed: %f, Gravity: %f", i, torques[i],
+    CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Joint: %d, Actual Torque: %f, Max Allowed: %f, Gravity: %f", i, torques[i],
              max_torques_[i], zero_torques[i]);
-    logDebug("moveit.dynamics_solver: Joint: %d, Payload Allowed (N): %f", i, payload_joint);
+    CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Joint: %d, Payload Allowed (N): %f", i, payload_joint);
     if (payload_joint < min_payload)
     {
       min_payload = payload_joint;
@@ -270,7 +270,7 @@ bool DynamicsSolver::getMaxPayload(const std::vector<double>& joint_angles, doub
     }
   }
   payload = min_payload / gravity_;
-  logDebug("moveit.dynamics_solver: Max payload (kg): %f", payload);
+  CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Max payload (kg): %f", payload);
   return true;
 }
 
@@ -279,17 +279,17 @@ bool DynamicsSolver::getPayloadTorques(const std::vector<double>& joint_angles,
 {
   if (!joint_model_group_)
   {
-    logDebug("moveit.dynamics_solver: Did not construct DynamicsSolver object properly. Check error logs.");
+    CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: Did not construct DynamicsSolver object properly. Check error logs.");
     return false;
   }
   if (joint_angles.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Joint angles vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Joint angles vector should be size %d", num_joints_);
     return false;
   }
   if (joint_torques.size() != num_joints_)
   {
-    logError("moveit.dynamics_solver: Joint torques vector should be size %d", num_joints_);
+    CONSOLE_BRIDGE_logError("moveit.dynamics_solver: Joint torques vector should be size %d", num_joints_);
     return false;
   }
   std::vector<double> joint_velocities(num_joints_, 0.0), joint_accelerations(num_joints_, 0.0);
@@ -303,7 +303,7 @@ bool DynamicsSolver::getPayloadTorques(const std::vector<double>& joint_angles,
   wrenches.back().force = transformVector(transform, wrenches.back().force);
   wrenches.back().torque = transformVector(transform, wrenches.back().torque);
 
-  logDebug("moveit.dynamics_solver: New wrench (local frame): %f %f %f", wrenches.back().force.x,
+  CONSOLE_BRIDGE_logDebug("moveit.dynamics_solver: New wrench (local frame): %f %f %f", wrenches.back().force.x,
            wrenches.back().force.y, wrenches.back().force.z);
 
   if (!getTorques(joint_angles, joint_velocities, joint_accelerations, wrenches, joint_torques))
diff --git a/exceptions/src/exceptions.cpp b/exceptions/src/exceptions.cpp
index c34fad8..35a6139 100644
--- a/exceptions/src/exceptions.cpp
+++ b/exceptions/src/exceptions.cpp
@@ -39,10 +39,10 @@
 
 moveit::ConstructException::ConstructException(const std::string& what_arg) : std::runtime_error(what_arg)
 {
-  logError("Error during construction of object: %s\nException thrown.", what_arg.c_str());
+  CONSOLE_BRIDGE_logError("Error during construction of object: %s\nException thrown.", what_arg.c_str());
 }
 
 moveit::Exception::Exception(const std::string& what_arg) : std::runtime_error(what_arg)
 {
-  logError("%s\nException thrown.", what_arg.c_str());
+  CONSOLE_BRIDGE_logError("%s\nException thrown.", what_arg.c_str());
 }
diff --git a/kinematic_constraints/src/kinematic_constraint.cpp b/kinematic_constraints/src/kinematic_constraint.cpp
index a64c300..9e8ebb6 100644
--- a/kinematic_constraints/src/kinematic_constraint.cpp
+++ b/kinematic_constraints/src/kinematic_constraint.cpp
@@ -76,7 +76,7 @@ bool kinematic_constraints::JointConstraint::configure(const moveit_msgs::JointC
   // testing tolerances first
   if (jc.tolerance_above < 0.0 || jc.tolerance_below < 0.0)
   {
-    logWarn("JointConstraint tolerance values must be positive.");
+    CONSOLE_BRIDGE_logWarn("JointConstraint tolerance values must be positive.");
     joint_model_ = NULL;
     return false;
   }
@@ -105,12 +105,12 @@ bool kinematic_constraints::JointConstraint::configure(const moveit_msgs::JointC
       // check if the joint has 1 DOF (the only kind we can handle)
       if (joint_model_->getVariableCount() == 0)
       {
-        logError("Joint '%s' has no parameters to constrain", jc.joint_name.c_str());
+        CONSOLE_BRIDGE_logError("Joint '%s' has no parameters to constrain", jc.joint_name.c_str());
         joint_model_ = NULL;
       }
       else if (joint_model_->getVariableCount() > 1)
       {
-        logError("Joint '%s' has more than one parameter to constrain. This type of constraint is not supported.",
+        CONSOLE_BRIDGE_logError("Joint '%s' has more than one parameter to constrain. This type of constraint is not supported.",
                  jc.joint_name.c_str());
         joint_model_ = NULL;
       }
@@ -127,7 +127,7 @@ bool kinematic_constraints::JointConstraint::configure(const moveit_msgs::JointC
         }
       if (found < 0)
       {
-        logError("Local variable name '%s' is not known to joint '%s'", local_variable_name_.c_str(),
+        CONSOLE_BRIDGE_logError("Local variable name '%s' is not known to joint '%s'", local_variable_name_.c_str(),
                  joint_model_->getName().c_str());
         joint_model_ = NULL;
       }
@@ -168,21 +168,21 @@ bool kinematic_constraints::JointConstraint::configure(const moveit_msgs::JointC
       {
         joint_position_ = bounds.min_position_;
         joint_tolerance_above_ = std::numeric_limits<double>::epsilon();
-        logWarn("Joint %s is constrained to be below the minimum bounds. Assuming minimum bounds instead.",
+        CONSOLE_BRIDGE_logWarn("Joint %s is constrained to be below the minimum bounds. Assuming minimum bounds instead.",
                 jc.joint_name.c_str());
       }
       else if (bounds.max_position_ < joint_position_ - joint_tolerance_below_)
       {
         joint_position_ = bounds.max_position_;
         joint_tolerance_below_ = std::numeric_limits<double>::epsilon();
-        logWarn("Joint %s is constrained to be above the maximum bounds. Assuming maximum bounds instead.",
+        CONSOLE_BRIDGE_logWarn("Joint %s is constrained to be above the maximum bounds. Assuming maximum bounds instead.",
                 jc.joint_name.c_str());
       }
     }
 
     if (jc.weight <= std::numeric_limits<double>::epsilon())
     {
-      logWarn("The weight on constraint for joint '%s' is very near zero.  Setting to 1.0.", jc.joint_name.c_str());
+      CONSOLE_BRIDGE_logWarn("The weight on constraint for joint '%s' is very near zero.  Setting to 1.0.", jc.joint_name.c_str());
       constraint_weight_ = 1.0;
     }
     else
@@ -277,14 +277,14 @@ bool kinematic_constraints::PositionConstraint::configure(const moveit_msgs::Pos
   link_model_ = robot_model_->getLinkModel(pc.link_name);
   if (link_model_ == NULL)
   {
-    logWarn("Position constraint link model %s not found in kinematic model.  Constraint invalid.",
+    CONSOLE_BRIDGE_logWarn("Position constraint link model %s not found in kinematic model.  Constraint invalid.",
             pc.link_name.c_str());
     return false;
   }
 
   if (pc.header.frame_id.empty())
   {
-    logWarn("No frame specified for position constraint on link '%s'!", pc.link_name.c_str());
+    CONSOLE_BRIDGE_logWarn("No frame specified for position constraint on link '%s'!", pc.link_name.c_str());
     return false;
   }
 
@@ -310,7 +310,7 @@ bool kinematic_constraints::PositionConstraint::configure(const moveit_msgs::Pos
     {
       if (pc.constraint_region.primitive_poses.size() <= i)
       {
-        logWarn("Constraint region message does not contain enough primitive poses");
+        CONSOLE_BRIDGE_logWarn("Constraint region message does not contain enough primitive poses");
         continue;
       }
       constraint_region_.push_back(bodies::BodyPtr(bodies::createBodyFromShape(shape.get())));
@@ -326,7 +326,7 @@ bool kinematic_constraints::PositionConstraint::configure(const moveit_msgs::Pos
       }
     }
     else
-      logWarn("Could not construct primitive shape %d", i);
+      CONSOLE_BRIDGE_logWarn("Could not construct primitive shape %d", i);
   }
 
   // load meshes
@@ -337,7 +337,7 @@ bool kinematic_constraints::PositionConstraint::configure(const moveit_msgs::Pos
     {
       if (pc.constraint_region.mesh_poses.size() <= i)
       {
-        logWarn("Constraint region message does not contain enough primitive poses");
+        CONSOLE_BRIDGE_logWarn("Constraint region message does not contain enough primitive poses");
         continue;
       }
       constraint_region_.push_back(bodies::BodyPtr(bodies::createBodyFromShape(shape.get())));
@@ -354,13 +354,13 @@ bool kinematic_constraints::PositionConstraint::configure(const moveit_msgs::Pos
     }
     else
     {
-      logWarn("Could not construct mesh shape %d", i);
+      CONSOLE_BRIDGE_logWarn("Could not construct mesh shape %d", i);
     }
   }
 
   if (pc.weight <= std::numeric_limits<double>::epsilon())
   {
-    logWarn("The weight on position constraint for link '%s' is near zero.  Setting to 1.0.", pc.link_name.c_str());
+    CONSOLE_BRIDGE_logWarn("The weight on position constraint for link '%s' is near zero.  Setting to 1.0.", pc.link_name.c_str());
     constraint_weight_ = 1.0;
   }
   else
@@ -498,20 +498,20 @@ bool kinematic_constraints::OrientationConstraint::configure(const moveit_msgs::
   link_model_ = robot_model_->getLinkModel(oc.link_name);
   if (!link_model_)
   {
-    logWarn("Could not find link model for link name %s", oc.link_name.c_str());
+    CONSOLE_BRIDGE_logWarn("Could not find link model for link name %s", oc.link_name.c_str());
     return false;
   }
   Eigen::Quaterniond q;
   tf::quaternionMsgToEigen(oc.orientation, q);
   if (fabs(q.norm() - 1.0) > 1e-3)
   {
-    logWarn("Orientation constraint for link '%s' is probably incorrect: %f, %f, %f, %f. Assuming identity instead.",
+    CONSOLE_BRIDGE_logWarn("Orientation constraint for link '%s' is probably incorrect: %f, %f, %f, %f. Assuming identity instead.",
             oc.link_name.c_str(), oc.orientation.x, oc.orientation.y, oc.orientation.z, oc.orientation.w);
     q = Eigen::Quaterniond(1.0, 0.0, 0.0, 0.0);
   }
 
   if (oc.header.frame_id.empty())
-    logWarn("No frame specified for position constraint on link '%s'!", oc.link_name.c_str());
+    CONSOLE_BRIDGE_logWarn("No frame specified for position constraint on link '%s'!", oc.link_name.c_str());
 
   if (tf.isFixedFrame(oc.header.frame_id))
   {
@@ -529,25 +529,25 @@ bool kinematic_constraints::OrientationConstraint::configure(const moveit_msgs::
   }
   std::stringstream matrix_str;
   matrix_str << desired_rotation_matrix_;
-  logDebug("The desired rotation matrix for link '%s' in frame %s is:\n%s", oc.link_name.c_str(),
+  CONSOLE_BRIDGE_logDebug("The desired rotation matrix for link '%s' in frame %s is:\n%s", oc.link_name.c_str(),
            desired_rotation_frame_id_.c_str(), matrix_str.str().c_str());
 
   if (oc.weight <= std::numeric_limits<double>::epsilon())
   {
-    logWarn("The weight on position constraint for link '%s' is near zero.  Setting to 1.0.", oc.link_name.c_str());
+    CONSOLE_BRIDGE_logWarn("The weight on position constraint for link '%s' is near zero.  Setting to 1.0.", oc.link_name.c_str());
     constraint_weight_ = 1.0;
   }
   else
     constraint_weight_ = oc.weight;
   absolute_x_axis_tolerance_ = fabs(oc.absolute_x_axis_tolerance);
   if (absolute_x_axis_tolerance_ < std::numeric_limits<double>::epsilon())
-    logWarn("Near-zero value for absolute_x_axis_tolerance");
+    CONSOLE_BRIDGE_logWarn("Near-zero value for absolute_x_axis_tolerance");
   absolute_y_axis_tolerance_ = fabs(oc.absolute_y_axis_tolerance);
   if (absolute_y_axis_tolerance_ < std::numeric_limits<double>::epsilon())
-    logWarn("Near-zero value for absolute_y_axis_tolerance");
+    CONSOLE_BRIDGE_logWarn("Near-zero value for absolute_y_axis_tolerance");
   absolute_z_axis_tolerance_ = fabs(oc.absolute_z_axis_tolerance);
   if (absolute_z_axis_tolerance_ < std::numeric_limits<double>::epsilon())
-    logWarn("Near-zero value for absolute_z_axis_tolerance");
+    CONSOLE_BRIDGE_logWarn("Near-zero value for absolute_z_axis_tolerance");
 
   return link_model_ != NULL;
 }
@@ -669,11 +669,11 @@ bool kinematic_constraints::VisibilityConstraint::configure(const moveit_msgs::V
   target_radius_ = fabs(vc.target_radius);
 
   if (vc.target_radius <= std::numeric_limits<double>::epsilon())
-    logWarn("The radius of the target disc that must be visible should be strictly positive");
+    CONSOLE_BRIDGE_logWarn("The radius of the target disc that must be visible should be strictly positive");
 
   if (vc.cone_sides < 3)
   {
-    logWarn("The number of sides for the visibility region must be 3 or more. Assuming 3 sides instead of the "
+    CONSOLE_BRIDGE_logWarn("The number of sides for the visibility region must be 3 or more. Assuming 3 sides instead of the "
             "specified %d",
             vc.cone_sides);
     cone_sides_ = 3;
@@ -725,7 +725,7 @@ bool kinematic_constraints::VisibilityConstraint::configure(const moveit_msgs::V
 
   if (vc.weight <= std::numeric_limits<double>::epsilon())
   {
-    logWarn("The weight of visibility constraint is near zero.  Setting to 1.0.");
+    CONSOLE_BRIDGE_logWarn("The weight of visibility constraint is near zero.  Setting to 1.0.");
     constraint_weight_ = 1.0;
   }
   else
@@ -1014,7 +1014,7 @@ bool kinematic_constraints::VisibilityConstraint::decideContact(const collision_
       (robot_state::Transforms::sameFrame(contact.body_name_1, sensor_frame_id_) ||
        robot_state::Transforms::sameFrame(contact.body_name_1, target_frame_id_)))
   {
-    logDebug("Accepted collision with either sensor or target");
+    CONSOLE_BRIDGE_logDebug("Accepted collision with either sensor or target");
     return true;
   }
   if (contact.body_type_2 == collision_detection::BodyTypes::ROBOT_LINK &&
@@ -1022,7 +1022,7 @@ bool kinematic_constraints::VisibilityConstraint::decideContact(const collision_
       (robot_state::Transforms::sameFrame(contact.body_name_2, sensor_frame_id_) ||
        robot_state::Transforms::sameFrame(contact.body_name_2, target_frame_id_)))
   {
-    logDebug("Accepted collision with either sensor or target");
+    CONSOLE_BRIDGE_logDebug("Accepted collision with either sensor or target");
     return true;
   }
   return false;
diff --git a/kinematic_constraints/src/utils.cpp b/kinematic_constraints/src/utils.cpp
index 8fd8775..cfd8bb9 100644
--- a/kinematic_constraints/src/utils.cpp
+++ b/kinematic_constraints/src/utils.cpp
@@ -59,7 +59,7 @@ moveit_msgs::Constraints kinematic_constraints::mergeConstraints(const moveit_ms
         double low = std::max(a.position - a.tolerance_below, b.position - b.tolerance_below);
         double high = std::min(a.position + a.tolerance_above, b.position + b.tolerance_above);
         if (low > high)
-          logError("Attempted to merge incompatible constraints for joint '%s'. Discarding constraint.",
+          CONSOLE_BRIDGE_logError("Attempted to merge incompatible constraints for joint '%s'. Discarding constraint.",
                    a.joint_name.c_str());
         else
         {
diff --git a/kinematics_base/src/kinematics_base.cpp b/kinematics_base/src/kinematics_base.cpp
index ee3c3a1..f80636d 100644
--- a/kinematics_base/src/kinematics_base.cpp
+++ b/kinematics_base/src/kinematics_base.cpp
@@ -143,14 +143,14 @@ bool kinematics::KinematicsBase::getPositionIK(const std::vector<geometry_msgs::
 
   if (ik_poses.size() != 1)
   {
-    logError("moveit.kinematics_base: This kinematic solver does not support getPositionIK for multiple poses");
+    CONSOLE_BRIDGE_logError("moveit.kinematics_base: This kinematic solver does not support getPositionIK for multiple poses");
     result.kinematic_error = kinematics::KinematicErrors::MULTIPLE_TIPS_NOT_SUPPORTED;
     return false;
   }
 
   if (ik_poses.size() == 0)
   {
-    logError("moveit.kinematics_base: Input ik_poses array is empty");
+    CONSOLE_BRIDGE_logError("moveit.kinematics_base: Input ik_poses array is empty");
     result.kinematic_error = kinematics::KinematicErrors::EMPTY_TIP_POSES;
     return false;
   }
diff --git a/kinematics_metrics/src/kinematics_metrics.cpp b/kinematics_metrics/src/kinematics_metrics.cpp
index c6abe32..71f7256 100644
--- a/kinematics_metrics/src/kinematics_metrics.cpp
+++ b/kinematics_metrics/src/kinematics_metrics.cpp
@@ -122,7 +122,7 @@ bool KinematicsMetrics::getManipulabilityIndex(const robot_state::RobotState& st
       manipulability_index = 1.0;
       for (unsigned int i = 0; i < singular_values.rows(); ++i)
       {
-        logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
+        CONSOLE_BRIDGE_logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
         manipulability_index *= singular_values(i, 0);
       }
       // Get manipulability index
@@ -145,7 +145,7 @@ bool KinematicsMetrics::getManipulabilityIndex(const robot_state::RobotState& st
       manipulability_index = 1.0;
       for (unsigned int i = 0; i < singular_values.rows(); ++i)
       {
-        logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
+        CONSOLE_BRIDGE_logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
         manipulability_index *= singular_values(i, 0);
       }
       // Get manipulability index
@@ -218,7 +218,7 @@ bool KinematicsMetrics::getManipulability(const robot_state::RobotState& state,
     Eigen::JacobiSVD<Eigen::MatrixXd> svdsolver(jacobian.topLeftCorner(3, jacobian.cols()));
     Eigen::MatrixXd singular_values = svdsolver.singularValues();
     for (int i = 0; i < singular_values.rows(); ++i)
-      logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
+      CONSOLE_BRIDGE_logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
     manipulability = penalty * singular_values.minCoeff() / singular_values.maxCoeff();
   }
   else
@@ -227,7 +227,7 @@ bool KinematicsMetrics::getManipulability(const robot_state::RobotState& state,
     Eigen::JacobiSVD<Eigen::MatrixXd> svdsolver(jacobian);
     Eigen::MatrixXd singular_values = svdsolver.singularValues();
     for (int i = 0; i < singular_values.rows(); ++i)
-      logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
+      CONSOLE_BRIDGE_logDebug("moveit.kin_metrics: Singular value: %d %f", i, singular_values(i, 0));
     manipulability = penalty * singular_values.minCoeff() / singular_values.maxCoeff();
   }
   return true;
diff --git a/planning_interface/src/planning_interface.cpp b/planning_interface/src/planning_interface.cpp
index 55cbe48..71965a4 100644
--- a/planning_interface/src/planning_interface.cpp
+++ b/planning_interface/src/planning_interface.cpp
@@ -84,7 +84,7 @@ void planning_interface::PlanningContext::setMotionPlanRequest(const MotionPlanR
     request_.allowed_planning_time = 1.0;
   }
   if (request_.num_planning_attempts < 0)
-    logError("The number of desired planning attempts should be positive. Assuming one attempt.");
+    CONSOLE_BRIDGE_logError("The number of desired planning attempts should be positive. Assuming one attempt.");
   request_.num_planning_attempts = std::max(1, request_.num_planning_attempts);
 }
 
diff --git a/planning_request_adapter/src/planning_request_adapter.cpp b/planning_request_adapter/src/planning_request_adapter.cpp
index 4ed07be..0c16253 100644
--- a/planning_request_adapter/src/planning_request_adapter.cpp
+++ b/planning_request_adapter/src/planning_request_adapter.cpp
@@ -92,7 +92,7 @@ bool callAdapter1(const PlanningRequestAdapter* adapter, const planning_interfac
   }
   catch (std::exception& ex)
   {
-    logError("Exception caught executing *final* adapter '%s': %s", adapter->getDescription().c_str(), ex.what());
+    CONSOLE_BRIDGE_logError("Exception caught executing *final* adapter '%s': %s", adapter->getDescription().c_str(), ex.what());
     added_path_index.clear();
     return callPlannerInterfaceSolve(planner.get(), planning_scene, req, res);
   }
@@ -109,7 +109,7 @@ bool callAdapter2(const PlanningRequestAdapter* adapter, const PlanningRequestAd
   }
   catch (std::exception& ex)
   {
-    logError("Exception caught executing *next* adapter '%s': %s", adapter->getDescription().c_str(), ex.what());
+    CONSOLE_BRIDGE_logError("Exception caught executing *next* adapter '%s': %s", adapter->getDescription().c_str(), ex.what());
     added_path_index.clear();
     return planner(planning_scene, req, res);
   }
diff --git a/planning_scene/src/planning_scene.cpp b/planning_scene/src/planning_scene.cpp
index 7badeda..f562206 100644
--- a/planning_scene/src/planning_scene.cpp
+++ b/planning_scene/src/planning_scene.cpp
@@ -355,7 +355,7 @@ bool planning_scene::PlanningScene::setActiveCollisionDetector(const std::string
   }
   else
   {
-    logError("Cannot setActiveCollisionDetector to '%s' -- it has been added to PlanningScene.  Keeping existing "
+    CONSOLE_BRIDGE_logError("Cannot setActiveCollisionDetector to '%s' -- it has been added to PlanningScene.  Keeping existing "
              "active collision detector '%s'",
              collision_detector_name.c_str(), active_collision_->alloc_->getName().c_str());
     return false;
@@ -376,7 +376,7 @@ planning_scene::PlanningScene::getCollisionWorld(const std::string& collision_de
   CollisionDetectorConstIterator it = collision_.find(collision_detector_name);
   if (it == collision_.end())
   {
-    logError("Could not get CollisionWorld named '%s'.  Returning active CollisionWorld '%s' instead",
+    CONSOLE_BRIDGE_logError("Could not get CollisionWorld named '%s'.  Returning active CollisionWorld '%s' instead",
              collision_detector_name.c_str(), active_collision_->alloc_->getName().c_str());
     return active_collision_->cworld_const_;
   }
@@ -390,7 +390,7 @@ planning_scene::PlanningScene::getCollisionRobot(const std::string& collision_de
   CollisionDetectorConstIterator it = collision_.find(collision_detector_name);
   if (it == collision_.end())
   {
-    logError("Could not get CollisionRobot named '%s'.  Returning active CollisionRobot '%s' instead",
+    CONSOLE_BRIDGE_logError("Could not get CollisionRobot named '%s'.  Returning active CollisionRobot '%s' instead",
              collision_detector_name.c_str(), active_collision_->alloc_->getName().c_str());
     return active_collision_->getCollisionRobot();
   }
@@ -404,7 +404,7 @@ planning_scene::PlanningScene::getCollisionRobotUnpadded(const std::string& coll
   CollisionDetectorConstIterator it = collision_.find(collision_detector_name);
   if (it == collision_.end())
   {
-    logError("Could not get CollisionRobotUnpadded named '%s'.  Returning active CollisionRobotUnpadded '%s' instead",
+    CONSOLE_BRIDGE_logError("Could not get CollisionRobotUnpadded named '%s'.  Returning active CollisionRobotUnpadded '%s' instead",
              collision_detector_name.c_str(), active_collision_->alloc_->getName().c_str());
     return active_collision_->getCollisionRobotUnpadded();
   }
@@ -899,7 +899,7 @@ bool planning_scene::PlanningScene::getOctomapMsg(octomap_msgs::OctomapWithPose&
       tf::poseEigenToMsg(map->shape_poses_[0], octomap.origin);
       return true;
     }
-    logError("Unexpected number of shapes in octomap collision object. Not including '%s' object", OCTOMAP_NS.c_str());
+    CONSOLE_BRIDGE_logError("Unexpected number of shapes in octomap collision object. Not including '%s' object", OCTOMAP_NS.c_str());
   }
   return false;
 }
@@ -1118,7 +1118,7 @@ void planning_scene::PlanningScene::setCurrentState(const moveit_msgs::RobotStat
   {
     if (!state.is_diff && state.attached_collision_objects[i].object.operation != moveit_msgs::CollisionObject::ADD)
     {
-      logError("The specified RobotState is not marked as is_diff. The request to modify the object '%s' is not "
+      CONSOLE_BRIDGE_logError("The specified RobotState is not marked as is_diff. The request to modify the object '%s' is not "
                "supported. Object is ignored.",
                state.attached_collision_objects[i].object.id.c_str());
       continue;
@@ -1206,12 +1206,12 @@ bool planning_scene::PlanningScene::setPlanningSceneDiffMsg(const moveit_msgs::P
 {
   bool result = true;
 
-  logDebug("moveit.planning_scene: Adding planning scene diff");
+  CONSOLE_BRIDGE_logDebug("moveit.planning_scene: Adding planning scene diff");
   if (!scene_msg.name.empty())
     name_ = scene_msg.name;
 
   if (!scene_msg.robot_model_name.empty() && scene_msg.robot_model_name != getRobotModel()->getName())
-    logWarn("Setting the scene for model '%s' but model '%s' is loaded.", scene_msg.robot_model_name.c_str(),
+    CONSOLE_BRIDGE_logWarn("Setting the scene for model '%s' but model '%s' is loaded.", scene_msg.robot_model_name.c_str(),
             getRobotModel()->getName().c_str());
 
   // there is at least one transform in the list of fixed transform: from model frame to itself;
@@ -1263,11 +1263,11 @@ bool planning_scene::PlanningScene::setPlanningSceneDiffMsg(const moveit_msgs::P
 
 bool planning_scene::PlanningScene::setPlanningSceneMsg(const moveit_msgs::PlanningScene& scene_msg)
 {
-  logDebug("moveit.planning_scene: Setting new planning scene: '%s'", scene_msg.name.c_str());
+  CONSOLE_BRIDGE_logDebug("moveit.planning_scene: Setting new planning scene: '%s'", scene_msg.name.c_str());
   name_ = scene_msg.name;
 
   if (!scene_msg.robot_model_name.empty() && scene_msg.robot_model_name != getRobotModel()->getName())
-    logWarn("Setting the scene for model '%s' but model '%s' is loaded.", scene_msg.robot_model_name.c_str(),
+    CONSOLE_BRIDGE_logWarn("Setting the scene for model '%s' but model '%s' is loaded.", scene_msg.robot_model_name.c_str(),
             getRobotModel()->getName().c_str());
 
   if (parent_)
@@ -1321,7 +1321,7 @@ void planning_scene::PlanningScene::processOctomapMsg(const octomap_msgs::Octoma
 
   if (map.id != "OcTree")
   {
-    logError("Received octomap is of type '%s' but type 'OcTree' is expected.", map.id.c_str());
+    CONSOLE_BRIDGE_logError("Received octomap is of type '%s' but type 'OcTree' is expected.", map.id.c_str());
     return;
   }
 
@@ -1359,7 +1359,7 @@ void planning_scene::PlanningScene::processOctomapMsg(const octomap_msgs::Octoma
 
   if (map.octomap.id != "OcTree")
   {
-    logError("Received octomap is of type '%s' but type 'OcTree' is expected.", map.octomap.id.c_str());
+    CONSOLE_BRIDGE_logError("Received octomap is of type '%s' but type 'OcTree' is expected.", map.octomap.id.c_str());
     return;
   }
 
@@ -1410,13 +1410,13 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
 {
   if (object.object.operation == moveit_msgs::CollisionObject::ADD && !getRobotModel()->hasLinkModel(object.link_name))
   {
-    logError("Unable to attach a body to link '%s' (link not found)", object.link_name.c_str());
+    CONSOLE_BRIDGE_logError("Unable to attach a body to link '%s' (link not found)", object.link_name.c_str());
     return false;
   }
 
   if (object.object.id == OCTOMAP_NS)
   {
-    logError("The ID '%s' cannot be used for collision objects (name reserved)", OCTOMAP_NS.c_str());
+    CONSOLE_BRIDGE_logError("The ID '%s' cannot be used for collision objects (name reserved)", OCTOMAP_NS.c_str());
     return false;
   }
 
@@ -1432,19 +1432,19 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
   {
     if (object.object.primitives.size() != object.object.primitive_poses.size())
     {
-      logError("Number of primitive shapes does not match number of poses in attached collision object message");
+      CONSOLE_BRIDGE_logError("Number of primitive shapes does not match number of poses in attached collision object message");
       return false;
     }
 
     if (object.object.meshes.size() != object.object.mesh_poses.size())
     {
-      logError("Number of meshes does not match number of poses in attached collision object message");
+      CONSOLE_BRIDGE_logError("Number of meshes does not match number of poses in attached collision object message");
       return false;
     }
 
     if (object.object.planes.size() != object.object.plane_poses.size())
     {
-      logError("Number of planes does not match number of poses in attached collision object message");
+      CONSOLE_BRIDGE_logError("Number of planes does not match number of poses in attached collision object message");
       return false;
     }
 
@@ -1476,7 +1476,7 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
         }
         else
         {
-          logError("Attempting to attach object '%s' to link '%s' but no geometry specified and such an object does "
+          CONSOLE_BRIDGE_logError("Attempting to attach object '%s' to link '%s' but no geometry specified and such an object does "
                    "not exist in the collision world",
                    object.object.id.c_str(), object.link_name.c_str());
           return false;
@@ -1491,7 +1491,7 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
             logInform("Removing world object with the same name as newly attached object: '%s'",
                       object.object.id.c_str());
           else
-            logWarn("You tried to append geometry to an attached object that is actually a world object ('%s'). World "
+            CONSOLE_BRIDGE_logWarn("You tried to append geometry to an attached object that is actually a world object ('%s'). World "
                     "geometry is ignored.",
                     object.object.id.c_str());
         }
@@ -1542,7 +1542,7 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
 
       if (shapes.empty())
       {
-        logError("There is no geometry to attach to link '%s' as part of attached body '%s'", object.link_name.c_str(),
+        CONSOLE_BRIDGE_logError("There is no geometry to attach to link '%s' as part of attached body '%s'", object.link_name.c_str(),
                  object.object.id.c_str());
         return false;
       }
@@ -1580,7 +1580,7 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
       return true;
     }
     else
-      logError("Robot state is not compatible with robot model. This could be fatal.");
+      CONSOLE_BRIDGE_logError("Robot state is not compatible with robot model. This could be fatal.");
   }
   else if (object.object.operation == moveit_msgs::CollisionObject::REMOVE)
   {
@@ -1624,7 +1624,7 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
       kstate_->clearAttachedBody(name);
 
       if (world_->hasObject(name))
-        logWarn("The collision world already has an object with the same name as the body about to be detached. NOT "
+        CONSOLE_BRIDGE_logWarn("The collision world already has an object with the same name as the body about to be detached. NOT "
                 "adding the detached body '%s' to the collision world.",
                 object.object.id.c_str());
       else
@@ -1639,11 +1639,11 @@ bool planning_scene::PlanningScene::processAttachedCollisionObjectMsg(
   }
   else if (object.object.operation == moveit_msgs::CollisionObject::MOVE)
   {
-    logError("Move for attached objects not yet implemented");
+    CONSOLE_BRIDGE_logError("Move for attached objects not yet implemented");
   }
   else
   {
-    logError("Unknown collision object operation: %d", object.object.operation);
+    CONSOLE_BRIDGE_logError("Unknown collision object operation: %d", object.object.operation);
   }
 
   return false;
@@ -1653,7 +1653,7 @@ bool planning_scene::PlanningScene::processCollisionObjectMsg(const moveit_msgs:
 {
   if (object.id == OCTOMAP_NS)
   {
-    logError("The ID '%s' cannot be used for collision objects (name reserved)", OCTOMAP_NS.c_str());
+    CONSOLE_BRIDGE_logError("The ID '%s' cannot be used for collision objects (name reserved)", OCTOMAP_NS.c_str());
     return false;
   }
 
@@ -1661,25 +1661,25 @@ bool planning_scene::PlanningScene::processCollisionObjectMsg(const moveit_msgs:
   {
     if (object.primitives.empty() && object.meshes.empty() && object.planes.empty())
     {
-      logError("There are no shapes specified in the collision object message");
+      CONSOLE_BRIDGE_logError("There are no shapes specified in the collision object message");
       return false;
     }
 
     if (object.primitives.size() != object.primitive_poses.size())
     {
-      logError("Number of primitive shapes does not match number of poses in collision object message");
+      CONSOLE_BRIDGE_logError("Number of primitive shapes does not match number of poses in collision object message");
       return false;
     }
 
     if (object.meshes.size() != object.mesh_poses.size())
     {
-      logError("Number of meshes does not match number of poses in collision object message");
+      CONSOLE_BRIDGE_logError("Number of meshes does not match number of poses in collision object message");
       return false;
     }
 
     if (object.planes.size() != object.plane_poses.size())
     {
-      logError("Number of planes does not match number of poses in collision object message");
+      CONSOLE_BRIDGE_logError("Number of planes does not match number of poses in collision object message");
       return false;
     }
 
@@ -1742,7 +1742,7 @@ bool planning_scene::PlanningScene::processCollisionObjectMsg(const moveit_msgs:
     if (world_->hasObject(object.id))
     {
       if (!object.primitives.empty() || !object.meshes.empty() || !object.planes.empty())
-        logWarn("Move operation for object '%s' ignores the geometry specified in the message.", object.id.c_str());
+        CONSOLE_BRIDGE_logWarn("Move operation for object '%s' ignores the geometry specified in the message.", object.id.c_str());
 
       const Eigen::Affine3d& t = getTransforms().getTransform(object.header.frame_id);
       EigenSTL::vector_Affine3d new_poses;
@@ -1775,17 +1775,17 @@ bool planning_scene::PlanningScene::processCollisionObjectMsg(const moveit_msgs:
       }
       else
       {
-        logError("Number of supplied poses (%u) for object '%s' does not match number of shapes (%u). Not moving.",
+        CONSOLE_BRIDGE_logError("Number of supplied poses (%u) for object '%s' does not match number of shapes (%u). Not moving.",
                  (unsigned int)new_poses.size(), object.id.c_str(), (unsigned int)obj->shapes_.size());
         return false;
       }
       return true;
     }
     else
-      logError("World object '%s' does not exist. Cannot move.", object.id.c_str());
+      CONSOLE_BRIDGE_logError("World object '%s' does not exist. Cannot move.", object.id.c_str());
   }
   else
-    logError("Unknown collision object operation: %d", object.operation);
+    CONSOLE_BRIDGE_logError("Unknown collision object operation: %d", object.operation);
   return false;
 }
 
@@ -1814,7 +1814,7 @@ const Eigen::Affine3d& planning_scene::PlanningScene::getFrameTransform(const ro
     collision_detection::World::ObjectConstPtr obj = getWorld()->getObject(id);
     if (obj->shape_poses_.size() > 1)
     {
-      logWarn("More than one shapes in object '%s'. Using first one to decide transform", id.c_str());
+      CONSOLE_BRIDGE_logWarn("More than one shapes in object '%s'. Using first one to decide transform", id.c_str());
       return obj->shape_poses_[0];
     }
     else if (obj->shape_poses_.size() == 1)
diff --git a/robot_model/src/floating_joint_model.cpp b/robot_model/src/floating_joint_model.cpp
index 7ed4af2..52c73ae 100644
--- a/robot_model/src/floating_joint_model.cpp
+++ b/robot_model/src/floating_joint_model.cpp
@@ -172,7 +172,7 @@ bool moveit::core::FloatingJointModel::normalizeRotation(double* values) const
     double norm = sqrt(normSqr);
     if (norm < std::numeric_limits<double>::epsilon() * 100.0)
     {
-      logWarn("Quaternion is zero in RobotState representation. Setting to identity");
+      CONSOLE_BRIDGE_logWarn("Quaternion is zero in RobotState representation. Setting to identity");
       values[3] = 0.0;
       values[4] = 0.0;
       values[5] = 0.0;
diff --git a/robot_model/src/joint_model_group.cpp b/robot_model/src/joint_model_group.cpp
index f0f5cb1..603a9d1 100644
--- a/robot_model/src/joint_model_group.cpp
+++ b/robot_model/src/joint_model_group.cpp
@@ -297,7 +297,7 @@ const moveit::core::LinkModel* moveit::core::JointModelGroup::getLinkModel(const
   LinkModelMapConst::const_iterator it = link_model_map_.find(name);
   if (it == link_model_map_.end())
   {
-    logError("Link '%s' not found in group '%s'", name.c_str(), name_.c_str());
+    CONSOLE_BRIDGE_logError("Link '%s' not found in group '%s'", name.c_str(), name_.c_str());
     return NULL;
   }
   return it->second;
@@ -308,7 +308,7 @@ const moveit::core::JointModel* moveit::core::JointModelGroup::getJointModel(con
   JointModelMapConst::const_iterator it = joint_model_map_.find(name);
   if (it == joint_model_map_.end())
   {
-    logError("Joint '%s' not found in group '%s'", name.c_str(), name_.c_str());
+    CONSOLE_BRIDGE_logError("Joint '%s' not found in group '%s'", name.c_str(), name_.c_str());
     return NULL;
   }
   return it->second;
@@ -352,7 +352,7 @@ void moveit::core::JointModelGroup::getVariableRandomPositionsNearBy(
     if (iter != distance_map.end())
       distance = iter->second;
     else
-      logWarn("Did not pass in distance for '%s'", active_joint_model_vector_[i]->getName().c_str());
+      CONSOLE_BRIDGE_logWarn("Did not pass in distance for '%s'", active_joint_model_vector_[i]->getName().c_str());
     active_joint_model_vector_[i]->getVariableRandomPositionsNearBy(
         rng, values + active_joint_model_start_index_[i], *active_joint_bounds[i],
         near + active_joint_model_start_index_[i], distance);
@@ -515,7 +515,7 @@ bool moveit::core::JointModelGroup::getEndEffectorTips(std::vector<const LinkMod
     const JointModelGroup* eef = parent_model_->getEndEffector(getAttachedEndEffectorNames()[i]);
     if (!eef)
     {
-      logError("Unable to find joint model group for eef");
+      CONSOLE_BRIDGE_logError("Unable to find joint model group for eef");
       return false;
     }
     const std::string& eef_parent = eef->getEndEffectorParentGroup().second;
@@ -523,7 +523,7 @@ bool moveit::core::JointModelGroup::getEndEffectorTips(std::vector<const LinkMod
     const LinkModel* eef_link = parent_model_->getLinkModel(eef_parent);
     if (!eef_link)
     {
-      logError("Unable to find end effector link for eef");
+      CONSOLE_BRIDGE_logError("Unable to find end effector link for eef");
       return false;
     }
 
@@ -539,9 +539,9 @@ const moveit::core::LinkModel* moveit::core::JointModelGroup::getOnlyOneEndEffec
   if (tips.size() == 1)
     return tips.front();
   else if (tips.size() > 1)
-    logError("More than one end effector tip found for joint model group, so cannot return only one");
+    CONSOLE_BRIDGE_logError("More than one end effector tip found for joint model group, so cannot return only one");
   else
-    logError("No end effector tips found in joint model group");
+    CONSOLE_BRIDGE_logError("No end effector tips found in joint model group");
   return NULL;
 }
 
@@ -550,7 +550,7 @@ int moveit::core::JointModelGroup::getVariableGroupIndex(const std::string& vari
   VariableIndexMap::const_iterator it = joint_variables_index_map_.find(variable);
   if (it == joint_variables_index_map_.end())
   {
-    logError("Variable '%s' is not part of group '%s'", variable.c_str(), name_.c_str());
+    CONSOLE_BRIDGE_logError("Variable '%s' is not part of group '%s'", variable.c_str(), name_.c_str());
     return -1;
   }
   return it->second;
@@ -584,7 +584,7 @@ bool moveit::core::JointModelGroup::computeIKIndexBijection(const std::vector<st
       // skip reported fixed joints
       if (hasJointModel(ik_jnames[i]) && getJointModel(ik_jnames[i])->getType() == JointModel::FIXED)
         continue;
-      logError("IK solver computes joint values for joint '%s' but group '%s' does not contain such a joint.",
+      CONSOLE_BRIDGE_logError("IK solver computes joint values for joint '%s' but group '%s' does not contain such a joint.",
                ik_jnames[i].c_str(), getName().c_str());
       return false;
     }
@@ -640,7 +640,7 @@ bool moveit::core::JointModelGroup::canSetStateFromIK(const std::string& tip) co
 
   if (tip_frames.empty())
   {
-    logDebug("Group %s has no tip frame(s)", name_.c_str());
+    CONSOLE_BRIDGE_logDebug("Group %s has no tip frame(s)", name_.c_str());
     return false;
   }
 
@@ -650,7 +650,7 @@ bool moveit::core::JointModelGroup::canSetStateFromIK(const std::string& tip) co
     // remove frame reference, if specified
     const std::string& tip_local = tip[0] == '/' ? tip.substr(1) : tip;
     const std::string& tip_frame_local = tip_frames[i][0] == '/' ? tip_frames[i].substr(1) : tip_frames[i];
-    logDebug("joint_model_group.canSetStateFromIK: comparing input tip: %s to this groups tip: %s ", tip_local.c_str(),
+    CONSOLE_BRIDGE_logDebug("joint_model_group.canSetStateFromIK: comparing input tip: %s to this groups tip: %s ", tip_local.c_str(),
              tip_frame_local.c_str());
 
     // Check if the IK solver's tip is the same as the frame of inquiry
diff --git a/robot_model/src/robot_model.cpp b/robot_model/src/robot_model.cpp
index 7892a26..e1f2f20 100644
--- a/robot_model/src/robot_model.cpp
+++ b/robot_model/src/robot_model.cpp
@@ -94,25 +94,25 @@ void moveit::core::RobotModel::buildModel(const urdf::ModelInterface& urdf_model
     const urdf::Link* root_link_ptr = urdf_model.getRoot().get();
     model_frame_ = '/' + root_link_ptr->name;
 
-    logDebug("... building kinematic chain");
+    CONSOLE_BRIDGE_logDebug("... building kinematic chain");
     root_joint_ = buildRecursive(NULL, root_link_ptr, srdf_model);
     if (root_joint_)
       root_link_ = root_joint_->getChildLinkModel();
-    logDebug("... building mimic joints");
+    CONSOLE_BRIDGE_logDebug("... building mimic joints");
     buildMimic(urdf_model);
 
-    logDebug("... computing joint indexing");
+    CONSOLE_BRIDGE_logDebug("... computing joint indexing");
     buildJointInfo();
 
     if (link_models_with_collision_geometry_vector_.empty())
-      logWarn("No geometry is associated to any robot links");
+      CONSOLE_BRIDGE_logWarn("No geometry is associated to any robot links");
 
     // build groups
 
-    logDebug("... constructing joint groups");
+    CONSOLE_BRIDGE_logDebug("... constructing joint groups");
     buildGroups(srdf_model);
 
-    logDebug("... constructing joint group states");
+    CONSOLE_BRIDGE_logDebug("... constructing joint group states");
     buildGroupStates(srdf_model);
 
     // For debugging entire model
@@ -120,7 +120,7 @@ void moveit::core::RobotModel::buildModel(const urdf::ModelInterface& urdf_model
       printModelInfo(std::cout);
   }
   else
-    logWarn("No root link found");
+    CONSOLE_BRIDGE_logWarn("No root link found");
 }
 
 namespace moveit
@@ -340,20 +340,20 @@ void moveit::core::RobotModel::buildGroupStates(const srdf::Model& srdf_model)
             for (std::size_t j = 0; j < vn.size(); ++j)
               state[vn[j]] = jt->second[j];
           else
-            logError("The model for joint '%s' requires %d variable values, but only %d variable values were supplied "
+            CONSOLE_BRIDGE_logError("The model for joint '%s' requires %d variable values, but only %d variable values were supplied "
                      "in default state '%s' for group '%s'",
                      jt->first.c_str(), (int)vn.size(), (int)jt->second.size(), ds[i].name_.c_str(),
                      jmg->getName().c_str());
         }
         else
-          logError("Group state '%s' specifies value for joint '%s', but that joint is not part of group '%s'",
+          CONSOLE_BRIDGE_logError("Group state '%s' specifies value for joint '%s', but that joint is not part of group '%s'",
                    ds[i].name_.c_str(), jt->first.c_str(), jmg->getName().c_str());
       }
       if (!state.empty())
         jmg->addDefaultState(ds[i].name_, state);
     }
     else
-      logError("Group state '%s' specified for group '%s', but that group does not exist", ds[i].name_.c_str(),
+      CONSOLE_BRIDGE_logError("Group state '%s' specified for group '%s', but that group does not exist", ds[i].name_.c_str(),
                ds[i].group_.c_str());
   }
 }
@@ -373,11 +373,11 @@ void moveit::core::RobotModel::buildMimic(const urdf::ModelInterface& urdf_model
           if (joint_model_vector_[i]->getVariableCount() == jit->second->getVariableCount())
             joint_model_vector_[i]->setMimic(jit->second, jm->mimic->multiplier, jm->mimic->offset);
           else
-            logError("Join '%s' cannot mimic joint '%s' because they have different number of DOF",
+            CONSOLE_BRIDGE_logError("Join '%s' cannot mimic joint '%s' because they have different number of DOF",
                      joint_model_vector_[i]->getName().c_str(), jm->mimic->joint_name.c_str());
         }
         else
-          logError("Joint '%s' cannot mimic unknown joint '%s'", joint_model_vector_[i]->getName().c_str(),
+          CONSOLE_BRIDGE_logError("Joint '%s' cannot mimic unknown joint '%s'", joint_model_vector_[i]->getName().c_str(),
                    jm->mimic->joint_name.c_str());
       }
   }
@@ -401,7 +401,7 @@ void moveit::core::RobotModel::buildMimic(const urdf::ModelInterface& urdf_model
         }
         if (joint_model_vector_[i] == joint_model_vector_[i]->getMimic())
         {
-          logError("Cycle found in joint that mimic each other. Ignoring all mimic joints.");
+          CONSOLE_BRIDGE_logError("Cycle found in joint that mimic each other. Ignoring all mimic joints.");
           for (std::size_t i = 0; i < joint_model_vector_.size(); ++i)
             joint_model_vector_[i]->setMimic(NULL, 0.0, 0.0);
           change = false;
@@ -431,7 +431,7 @@ const moveit::core::JointModelGroup* moveit::core::RobotModel::getEndEffector(co
     it = joint_model_group_map_.find(name);
     if (it != joint_model_group_map_.end() && it->second->isEndEffector())
       return it->second;
-    logError("End-effector '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+    CONSOLE_BRIDGE_logError("End-effector '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
     return NULL;
   }
   return it->second;
@@ -445,7 +445,7 @@ moveit::core::JointModelGroup* moveit::core::RobotModel::getEndEffector(const st
     it = joint_model_group_map_.find(name);
     if (it != joint_model_group_map_.end() && it->second->isEndEffector())
       return it->second;
-    logError("End-effector '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+    CONSOLE_BRIDGE_logError("End-effector '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
     return NULL;
   }
   return it->second;
@@ -461,7 +461,7 @@ const moveit::core::JointModelGroup* moveit::core::RobotModel::getJointModelGrou
   JointModelGroupMap::const_iterator it = joint_model_group_map_.find(name);
   if (it == joint_model_group_map_.end())
   {
-    logError("Group '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+    CONSOLE_BRIDGE_logError("Group '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
     return NULL;
   }
   return it->second;
@@ -472,7 +472,7 @@ moveit::core::JointModelGroup* moveit::core::RobotModel::getJointModelGroup(cons
   JointModelGroupMap::const_iterator it = joint_model_group_map_.find(name);
   if (it == joint_model_group_map_.end())
   {
-    logError("Group '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+    CONSOLE_BRIDGE_logError("Group '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
     return NULL;
   }
   return it->second;
@@ -507,14 +507,14 @@ void moveit::core::RobotModel::buildGroups(const srdf::Model& srdf_model)
           added = true;
           processed[i] = true;
           if (!addJointModelGroup(group_configs[i]))
-            logWarn("Failed to add group '%s'", group_configs[i].name_.c_str());
+            CONSOLE_BRIDGE_logWarn("Failed to add group '%s'", group_configs[i].name_.c_str());
         }
       }
   }
 
   for (std::size_t i = 0; i < processed.size(); ++i)
     if (!processed[i])
-      logWarn("Could not process group '%s' due to unmet subgroup dependencies", group_configs[i].name_.c_str());
+      CONSOLE_BRIDGE_logWarn("Could not process group '%s' due to unmet subgroup dependencies", group_configs[i].name_.c_str());
 
   for (JointModelGroupMap::const_iterator it = joint_model_group_map_.begin(); it != joint_model_group_map_.end(); ++it)
     joint_model_groups_.push_back(it->second);
@@ -599,16 +599,16 @@ void moveit::core::RobotModel::buildGroupsInfo_EndEffectors(const srdf::Model& s
               if (jt->second != it->second)
                 eef_parent_group = jt->second;
               else
-                logError("Group '%s' for end-effector '%s' cannot be its own parent", eefs[k].parent_group_.c_str(),
+                CONSOLE_BRIDGE_logError("Group '%s' for end-effector '%s' cannot be its own parent", eefs[k].parent_group_.c_str(),
                          eefs[k].name_.c_str());
             }
             else
-              logError("Group '%s' was specified as parent group for end-effector '%s' but it does not include the "
+              CONSOLE_BRIDGE_logError("Group '%s' was specified as parent group for end-effector '%s' but it does not include the "
                        "parent link '%s'",
                        eefs[k].parent_group_.c_str(), eefs[k].name_.c_str(), eefs[k].parent_link_.c_str());
           }
           else
-            logError("Group name '%s' not found (specified as parent group for end-effector '%s')",
+            CONSOLE_BRIDGE_logError("Group name '%s' not found (specified as parent group for end-effector '%s')",
                      eefs[k].parent_group_.c_str(), eefs[k].name_.c_str());
         }
 
@@ -632,7 +632,7 @@ void moveit::core::RobotModel::buildGroupsInfo_EndEffectors(const srdf::Model& s
         }
         else
         {
-          logWarn("Could not identify parent group for end-effector '%s'", eefs[k].name_.c_str());
+          CONSOLE_BRIDGE_logWarn("Could not identify parent group for end-effector '%s'", eefs[k].name_.c_str());
           it->second->setEndEffectorParent("", eefs[k].parent_link_);
         }
         break;
@@ -645,7 +645,7 @@ bool moveit::core::RobotModel::addJointModelGroup(const srdf::Model::Group& gc)
 {
   if (joint_model_group_map_.find(gc.name_) != joint_model_group_map_.end())
   {
-    logWarn("A group named '%s' already exists. Not adding.", gc.name_.c_str());
+    CONSOLE_BRIDGE_logWarn("A group named '%s' already exists. Not adding.", gc.name_.c_str());
     return false;
   }
 
@@ -742,7 +742,7 @@ bool moveit::core::RobotModel::addJointModelGroup(const srdf::Model::Group& gc)
 
   if (jset.empty())
   {
-    logWarn("Group '%s' must have at least one valid joint", gc.name_.c_str());
+    CONSOLE_BRIDGE_logWarn("Group '%s' must have at least one valid joint", gc.name_.c_str());
     return false;
   }
 
@@ -889,7 +889,7 @@ moveit::core::JointModel* moveit::core::RobotModel::constructJointModel(const ur
         result = new FixedJointModel(urdf_joint->name);
         break;
       default:
-        logError("Unknown joint type: %d", (int)urdf_joint->type);
+        CONSOLE_BRIDGE_logError("Unknown joint type: %d", (int)urdf_joint->type);
         break;
     }
   }
@@ -900,12 +900,12 @@ moveit::core::JointModel* moveit::core::RobotModel::constructJointModel(const ur
     {
       if (vjoints[i].child_link_ != child_link->name)
       {
-        logWarn("Skipping virtual joint '%s' because its child frame '%s' does not match the URDF frame '%s'",
+        CONSOLE_BRIDGE_logWarn("Skipping virtual joint '%s' because its child frame '%s' does not match the URDF frame '%s'",
                 vjoints[i].name_.c_str(), vjoints[i].child_link_.c_str(), child_link->name.c_str());
       }
       else if (vjoints[i].parent_frame_.empty())
       {
-        logWarn("Skipping virtual joint '%s' because its parent frame is empty", vjoints[i].name_.c_str());
+        CONSOLE_BRIDGE_logWarn("Skipping virtual joint '%s' because its parent frame is empty", vjoints[i].name_.c_str());
       }
       else
       {
@@ -1062,7 +1062,7 @@ shapes::ShapePtr moveit::core::RobotModel::constructShape(const urdf::Geometry*
     }
     break;
     default:
-      logError("Unknown geometry type: %d", (int)geom->type);
+      CONSOLE_BRIDGE_logError("Unknown geometry type: %d", (int)geom->type);
       break;
   }
 
@@ -1084,7 +1084,7 @@ const moveit::core::JointModel* moveit::core::RobotModel::getJointModel(const st
   JointModelMap::const_iterator it = joint_model_map_.find(name);
   if (it != joint_model_map_.end())
     return it->second;
-  logError("Joint '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+  CONSOLE_BRIDGE_logError("Joint '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
   return NULL;
 }
 
@@ -1092,7 +1092,7 @@ const moveit::core::JointModel* moveit::core::RobotModel::getJointModel(int inde
 {
   if (index < 0 || index >= static_cast<int>(joint_model_vector_.size()))
   {
-    logError("Joint index '%i' out of bounds of joints in model '%s'", index, model_name_.c_str());
+    CONSOLE_BRIDGE_logError("Joint index '%i' out of bounds of joints in model '%s'", index, model_name_.c_str());
     return NULL;
   }
   assert(joint_model_vector_[index]->getJointIndex() == index);
@@ -1104,7 +1104,7 @@ moveit::core::JointModel* moveit::core::RobotModel::getJointModel(const std::str
   JointModelMap::const_iterator it = joint_model_map_.find(name);
   if (it != joint_model_map_.end())
     return it->second;
-  logError("Joint '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+  CONSOLE_BRIDGE_logError("Joint '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
   return NULL;
 }
 
@@ -1113,7 +1113,7 @@ const moveit::core::LinkModel* moveit::core::RobotModel::getLinkModel(const std:
   LinkModelMap::const_iterator it = link_model_map_.find(name);
   if (it != link_model_map_.end())
     return it->second;
-  logError("Link '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+  CONSOLE_BRIDGE_logError("Link '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
   return NULL;
 }
 
@@ -1121,7 +1121,7 @@ const moveit::core::LinkModel* moveit::core::RobotModel::getLinkModel(int index)
 {
   if (index < 0 || index >= static_cast<int>(link_model_vector_.size()))
   {
-    logError("Link index '%i' out of bounds of links in model '%s'", index, model_name_.c_str());
+    CONSOLE_BRIDGE_logError("Link index '%i' out of bounds of links in model '%s'", index, model_name_.c_str());
     return NULL;
   }
   assert(link_model_vector_[index]->getLinkIndex() == index);
@@ -1133,7 +1133,7 @@ moveit::core::LinkModel* moveit::core::RobotModel::getLinkModel(const std::strin
   LinkModelMap::const_iterator it = link_model_map_.find(name);
   if (it != link_model_map_.end())
     return it->second;
-  logError("Link '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
+  CONSOLE_BRIDGE_logError("Link '%s' not found in model '%s'", name.c_str(), model_name_.c_str());
   return NULL;
 }
 
@@ -1317,7 +1317,7 @@ void moveit::core::RobotModel::setKinematicsAllocators(const std::map<std::strin
           ss << subs[i]->getName() << " ";
           result.second[subs[i]] = allocators.find(subs[i]->getName())->second;
         }
-        logDebug("Added sub-group IK allocators for group '%s': [ %s]", jmg->getName().c_str(), ss.str().c_str());
+        CONSOLE_BRIDGE_logDebug("Added sub-group IK allocators for group '%s': [ %s]", jmg->getName().c_str(), ss.str().c_str());
       }
       jmg->setSolverAllocators(result);
     }
diff --git a/robot_state/src/conversions.cpp b/robot_state/src/conversions.cpp
index a8d48d8..015bd5b 100644
--- a/robot_state/src/conversions.cpp
+++ b/robot_state/src/conversions.cpp
@@ -54,7 +54,7 @@ static bool _jointStateToRobotState(const sensor_msgs::JointState& joint_state,
 {
   if (joint_state.name.size() != joint_state.position.size())
   {
-    logError("Different number of names and positions in JointState message: %u, %u",
+    CONSOLE_BRIDGE_logError("Different number of names and positions in JointState message: %u, %u",
              (unsigned int)joint_state.name.size(), (unsigned int)joint_state.position.size());
     return false;
   }
@@ -70,7 +70,7 @@ static bool _multiDOFJointsToRobotState(const sensor_msgs::MultiDOFJointState& m
   std::size_t nj = mjs.joint_names.size();
   if (nj != mjs.transforms.size())
   {
-    logError("Different number of names, values or frames in MultiDOFJointState message.");
+    CONSOLE_BRIDGE_logError("Different number of names, values or frames in MultiDOFJointState message.");
     return false;
   }
 
@@ -92,14 +92,14 @@ static bool _multiDOFJointsToRobotState(const sensor_msgs::MultiDOFJointState& m
       }
       catch (std::exception& ex)
       {
-        logError("Caught %s", ex.what());
+        CONSOLE_BRIDGE_logError("Caught %s", ex.what());
         error = true;
       }
     else
       error = true;
 
     if (error)
-      logWarn("The transform for multi-dof joints was specified in frame '%s' but it was not possible to transform "
+      CONSOLE_BRIDGE_logWarn("The transform for multi-dof joints was specified in frame '%s' but it was not possible to transform "
               "that to frame '%s'",
               mjs.header.frame_id.c_str(), state.getRobotModel()->getModelFrame().c_str());
   }
@@ -109,7 +109,7 @@ static bool _multiDOFJointsToRobotState(const sensor_msgs::MultiDOFJointState& m
     const std::string& joint_name = mjs.joint_names[i];
     if (!state.getRobotModel()->hasJointModel(joint_name))
     {
-      logWarn("No joint matching multi-dof joint '%s'", joint_name.c_str());
+      CONSOLE_BRIDGE_logWarn("No joint matching multi-dof joint '%s'", joint_name.c_str());
       error = true;
       continue;
     }
@@ -225,19 +225,19 @@ static void _msgToAttachedBody(const Transforms* tf, const moveit_msgs::Attached
     {
       if (aco.object.primitives.size() != aco.object.primitive_poses.size())
       {
-        logError("Number of primitive shapes does not match number of poses in collision object message");
+        CONSOLE_BRIDGE_logError("Number of primitive shapes does not match number of poses in collision object message");
         return;
       }
 
       if (aco.object.meshes.size() != aco.object.mesh_poses.size())
       {
-        logError("Number of meshes does not match number of poses in collision object message");
+        CONSOLE_BRIDGE_logError("Number of meshes does not match number of poses in collision object message");
         return;
       }
 
       if (aco.object.planes.size() != aco.object.plane_poses.size())
       {
-        logError("Number of planes does not match number of poses in collision object message");
+        CONSOLE_BRIDGE_logError("Number of planes does not match number of poses in collision object message");
         return;
       }
 
@@ -293,7 +293,7 @@ static void _msgToAttachedBody(const Transforms* tf, const moveit_msgs::Attached
           else
           {
             t0.setIdentity();
-            logError("Cannot properly transform from frame '%s'. The pose of the attached body may be incorrect",
+            CONSOLE_BRIDGE_logError("Cannot properly transform from frame '%s'. The pose of the attached body may be incorrect",
                      aco.object.header.frame_id.c_str());
           }
           Eigen::Affine3d t = state.getGlobalLinkTransform(lm).inverse() * t0;
@@ -302,28 +302,28 @@ static void _msgToAttachedBody(const Transforms* tf, const moveit_msgs::Attached
         }
 
         if (shapes.empty())
-          logError("There is no geometry to attach to link '%s' as part of attached body '%s'", aco.link_name.c_str(),
+          CONSOLE_BRIDGE_logError("There is no geometry to attach to link '%s' as part of attached body '%s'", aco.link_name.c_str(),
                    aco.object.id.c_str());
         else
         {
           if (state.clearAttachedBody(aco.object.id))
-            logDebug("The robot state already had an object named '%s' attached to link '%s'. The object was replaced.",
+            CONSOLE_BRIDGE_logDebug("The robot state already had an object named '%s' attached to link '%s'. The object was replaced.",
                      aco.object.id.c_str(), aco.link_name.c_str());
           state.attachBody(aco.object.id, shapes, poses, aco.touch_links, aco.link_name, aco.detach_posture);
-          logDebug("Attached object '%s' to link '%s'", aco.object.id.c_str(), aco.link_name.c_str());
+          CONSOLE_BRIDGE_logDebug("Attached object '%s' to link '%s'", aco.object.id.c_str(), aco.link_name.c_str());
         }
       }
     }
     else
-      logError("The attached body for link '%s' has no geometry", aco.link_name.c_str());
+      CONSOLE_BRIDGE_logError("The attached body for link '%s' has no geometry", aco.link_name.c_str());
   }
   else if (aco.object.operation == moveit_msgs::CollisionObject::REMOVE)
   {
     if (!state.clearAttachedBody(aco.object.id))
-      logError("The attached body '%s' can not be removed because it does not exist", aco.link_name.c_str());
+      CONSOLE_BRIDGE_logError("The attached body '%s' can not be removed because it does not exist", aco.link_name.c_str());
   }
   else
-    logError("Unknown collision object operation: %d", aco.object.operation);
+    CONSOLE_BRIDGE_logError("Unknown collision object operation: %d", aco.object.operation);
 }
 
 static bool _robotStateMsgToRobotStateHelper(const Transforms* tf, const moveit_msgs::RobotState& robot_state,
@@ -334,7 +334,7 @@ static bool _robotStateMsgToRobotStateHelper(const Transforms* tf, const moveit_
 
   if (!rs.is_diff && rs.joint_state.name.empty() && rs.multi_dof_joint_state.joint_names.empty())
   {
-    logError("Found empty JointState message");
+    CONSOLE_BRIDGE_logError("Found empty JointState message");
     return false;
   }
 
@@ -433,12 +433,12 @@ bool moveit::core::jointTrajPointToRobotState(const trajectory_msgs::JointTrajec
 {
   if (trajectory.points.empty() || point_id > trajectory.points.size() - 1)
   {
-    logError("Invalid point_id");
+    CONSOLE_BRIDGE_logError("Invalid point_id");
     return false;
   }
   if (trajectory.joint_names.empty())
   {
-    logError("No joint names specified");
+    CONSOLE_BRIDGE_logError("No joint names specified");
     return false;
   }
 
@@ -529,7 +529,7 @@ void moveit::core::streamToRobotState(RobotState& state, const std::string& line
   {
     // Get a variable
     if (!std::getline(lineStream, cell, separator[0]))
-      logError("Missing variable %i", i);
+      CONSOLE_BRIDGE_logError("Missing variable %i", i);
 
     state.getVariablePositions()[i] = boost::lexical_cast<double>(cell.c_str());
   }
diff --git a/robot_state/src/robot_state.cpp b/robot_state/src/robot_state.cpp
index c7d8286..25abe89 100644
--- a/robot_state/src/robot_state.cpp
+++ b/robot_state/src/robot_state.cpp
@@ -153,7 +153,7 @@ bool moveit::core::RobotState::checkJointTransforms(const JointModel* joint) con
 {
   if (dirtyJointTransform(joint))
   {
-    logWarn("Returning dirty joint transforms for joint '%s'", joint->getName().c_str());
+    CONSOLE_BRIDGE_logWarn("Returning dirty joint transforms for joint '%s'", joint->getName().c_str());
     return false;
   }
   return true;
@@ -163,7 +163,7 @@ bool moveit::core::RobotState::checkLinkTransforms() const
 {
   if (dirtyLinkTransforms())
   {
-    logWarn("Returning dirty link transforms");
+    CONSOLE_BRIDGE_logWarn("Returning dirty link transforms");
     return false;
   }
   return true;
@@ -173,7 +173,7 @@ bool moveit::core::RobotState::checkCollisionTransforms() const
 {
   if (dirtyCollisionBodyTransforms())
   {
-    logWarn("Returning dirty collision body transforms");
+    CONSOLE_BRIDGE_logWarn("Returning dirty collision body transforms");
     return false;
   }
   return true;
@@ -851,7 +851,7 @@ const moveit::core::AttachedBody* moveit::core::RobotState::getAttachedBody(cons
   std::map<std::string, AttachedBody*>::const_iterator it = attached_body_map_.find(id);
   if (it == attached_body_map_.end())
   {
-    logError("Attached body '%s' not found", id.c_str());
+    CONSOLE_BRIDGE_logError("Attached body '%s' not found", id.c_str());
     return NULL;
   }
   else
@@ -994,7 +994,7 @@ const Eigen::Affine3d& moveit::core::RobotState::getFrameTransform(const std::st
   std::map<std::string, AttachedBody*>::const_iterator jt = attached_body_map_.find(id);
   if (jt == attached_body_map_.end())
   {
-    logError("Transform from frame '%s' to frame '%s' is not known ('%s' should be a link name or an attached body "
+    CONSOLE_BRIDGE_logError("Transform from frame '%s' to frame '%s' is not known ('%s' should be a link name or an attached body "
              "id).",
              id.c_str(), robot_model_->getModelFrame().c_str(), id.c_str());
     return identity_transform;
@@ -1002,11 +1002,11 @@ const Eigen::Affine3d& moveit::core::RobotState::getFrameTransform(const std::st
   const EigenSTL::vector_Affine3d& tf = jt->second->getGlobalCollisionBodyTransforms();
   if (tf.empty())
   {
-    logError("Attached body '%s' has no geometry associated to it. No transform to return.", id.c_str());
+    CONSOLE_BRIDGE_logError("Attached body '%s' has no geometry associated to it. No transform to return.", id.c_str());
     return identity_transform;
   }
   if (tf.size() > 1)
-    logDebug("There are multiple geometries associated to attached body '%s'. Returning the transform for the first "
+    CONSOLE_BRIDGE_logDebug("There are multiple geometries associated to attached body '%s'. Returning the transform for the first "
              "one.",
              id.c_str());
   return tf[0];
@@ -1045,7 +1045,7 @@ void moveit::core::RobotState::getRobotMarkers(visualization_msgs::MarkerArray&
   ros::Time tm = ros::Time::now();
   for (std::size_t i = 0; i < link_names.size(); ++i)
   {
-    logDebug("Trying to get marker for link '%s'", link_names[i].c_str());
+    CONSOLE_BRIDGE_logDebug("Trying to get marker for link '%s'", link_names[i].c_str());
     const LinkModel* lm = robot_model_->getLinkModel(link_names[i]);
     if (!lm)
       continue;
@@ -1125,13 +1125,13 @@ bool moveit::core::RobotState::getJacobian(const JointModelGroup* group, const L
 
   if (!group->isChain())
   {
-    logError("The group '%s' is not a chain. Cannot compute Jacobian.", group->getName().c_str());
+    CONSOLE_BRIDGE_logError("The group '%s' is not a chain. Cannot compute Jacobian.", group->getName().c_str());
     return false;
   }
 
   if (!group->isLinkUpdated(link->getName()))
   {
-    logError("Link name '%s' does not exist in the chain '%s' or is not a child for this chain",
+    CONSOLE_BRIDGE_logError("Link name '%s' does not exist in the chain '%s' or is not a child for this chain",
              link->getName().c_str(), group->getName().c_str());
     return false;
   }
@@ -1148,7 +1148,7 @@ bool moveit::core::RobotState::getJacobian(const JointModelGroup* group, const L
   Eigen::Vector3d point_transform = link_transform * reference_point_position;
 
   /*
-  logDebug("Point from reference origin expressed in world coordinates: %f %f %f",
+  CONSOLE_BRIDGE_logDebug("Point from reference origin expressed in world coordinates: %f %f %f",
            point_transform.x(),
            point_transform.y(),
            point_transform.z());
@@ -1160,11 +1160,11 @@ bool moveit::core::RobotState::getJacobian(const JointModelGroup* group, const L
   while (link)
   {
     /*
-    logDebug("Link: %s, %f %f %f",link_state->getName().c_str(),
+    CONSOLE_BRIDGE_logDebug("Link: %s, %f %f %f",link_state->getName().c_str(),
              link_state->getGlobalLinkTransform().translation().x(),
              link_state->getGlobalLinkTransform().translation().y(),
              link_state->getGlobalLinkTransform().translation().z());
-    logDebug("Joint: %s",link_state->getParentJointState()->getName().c_str());
+    CONSOLE_BRIDGE_logDebug("Joint: %s",link_state->getParentJointState()->getName().c_str());
     */
     const JointModel* pjm = link->getParentJointModel();
     if (pjm->getVariableCount() > 0)
@@ -1197,7 +1197,7 @@ bool moveit::core::RobotState::getJacobian(const JointModelGroup* group, const L
         jacobian.block<3, 1>(3, joint_index + 2) = jacobian.block<3, 1>(3, joint_index + 2) + joint_axis;
       }
       else
-        logError("Unknown type of joint in Jacobian computation");
+        CONSOLE_BRIDGE_logError("Unknown type of joint in Jacobian computation");
     }
     if (pjm == root_joint_model)
       break;
@@ -1305,7 +1305,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const geome
   const kinematics::KinematicsBaseConstPtr& solver = jmg->getSolverInstance();
   if (!solver)
   {
-    logError("No kinematics solver instantiated for group '%s'", jmg->getName().c_str());
+    CONSOLE_BRIDGE_logError("No kinematics solver instantiated for group '%s'", jmg->getName().c_str());
     return false;
   }
   return setFromIK(jmg, pose, solver->getTipFrame(), attempts, timeout, constraint, options);
@@ -1329,7 +1329,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
   const kinematics::KinematicsBaseConstPtr& solver = jmg->getSolverInstance();
   if (!solver)
   {
-    logError("No kinematics solver instantiated for group '%s'", jmg->getName().c_str());
+    CONSOLE_BRIDGE_logError("No kinematics solver instantiated for group '%s'", jmg->getName().c_str());
     return false;
   }
   static std::vector<double> consistency_limits;
@@ -1426,7 +1426,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
   // Error check
   if (poses_in.size() != tips_in.size())
   {
-    logError("moveit.robot_state: Number of poses must be the same as number of tips");
+    CONSOLE_BRIDGE_logError("moveit.robot_state: Number of poses must be the same as number of tips");
     return false;
   }
 
@@ -1445,7 +1445,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
     std::string error_msg;
     if (!solver->supportsGroup(jmg, &error_msg))
     {
-      logError("moveit.robot_state: Kinematics solver %s does not support joint group %s.  Error: %s",
+      CONSOLE_BRIDGE_logError("moveit.robot_state: Kinematics solver %s does not support joint group %s.  Error: %s",
                typeid(*solver).name(), jmg->getName().c_str(), error_msg.c_str());
       valid_solver = false;
     }
@@ -1461,7 +1461,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
     }
     else
     {
-      logError("moveit.robot_state: No kinematics solver instantiated for group '%s'", jmg->getName().c_str());
+      CONSOLE_BRIDGE_logError("moveit.robot_state: No kinematics solver instantiated for group '%s'", jmg->getName().c_str());
       return false;
     }
   }
@@ -1470,7 +1470,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
   std::vector<double> consistency_limits;
   if (consistency_limit_sets.size() > 1)
   {
-    logError("moveit.robot_state: Invalid number (%d) of sets of consistency limits for a setFromIK request that is "
+    CONSOLE_BRIDGE_logError("moveit.robot_state: Invalid number (%d) of sets of consistency limits for a setFromIK request that is "
              "being solved by a single IK solver",
              consistency_limit_sets.size());
     return false;
@@ -1527,7 +1527,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
           const EigenSTL::vector_Affine3d& ab_trans = ab->getFixedTransforms();
           if (ab_trans.size() != 1)
           {
-            logError("moveit.robot_state: Cannot use an attached body with multiple geometries as a reference frame.");
+            CONSOLE_BRIDGE_logError("moveit.robot_state: Cannot use an attached body with multiple geometries as a reference frame.");
             return false;
           }
           pose_frame = ab->getAttachedLinkName();
@@ -1562,12 +1562,12 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
     // Make sure one of the tip frames worked
     if (!found_valid_frame)
     {
-      logError("moveit.robot_state: Cannot compute IK for query %u pose reference frame '%s'", i, pose_frame.c_str());
+      CONSOLE_BRIDGE_logError("moveit.robot_state: Cannot compute IK for query %u pose reference frame '%s'", i, pose_frame.c_str());
       // Debug available tip frames
       std::stringstream ss;
       for (solver_tip_id = 0; solver_tip_id < solver_tip_frames.size(); ++solver_tip_id)
         ss << solver_tip_frames[solver_tip_id] << ", ";
-      logError("Available tip frames: [%s]", ss.str().c_str());
+      CONSOLE_BRIDGE_logError("Available tip frames: [%s]", ss.str().c_str());
       return false;
     }
 
@@ -1646,7 +1646,7 @@ bool moveit::core::RobotState::setFromIK(const JointModelGroup* jmg, const Eigen
     }
     else
     {
-      logDebug("moveit.robot_state: Rerunning IK solver with random joint positions");
+      CONSOLE_BRIDGE_logDebug("moveit.robot_state: Rerunning IK solver with random joint positions");
 
       // sample a random seed
       random_numbers::RandomNumberGenerator& rng = getRandomNumberGenerator();
@@ -1698,19 +1698,19 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
   // Error check
   if (poses_in.size() != sub_groups.size())
   {
-    logError("Number of poses (%u) must be the same as number of sub-groups (%u)", poses_in.size(), sub_groups.size());
+    CONSOLE_BRIDGE_logError("Number of poses (%u) must be the same as number of sub-groups (%u)", poses_in.size(), sub_groups.size());
     return false;
   }
 
   if (tips_in.size() != sub_groups.size())
   {
-    logError("Number of tip names (%u) must be same as number of sub-groups (%u)", tips_in.size(), sub_groups.size());
+    CONSOLE_BRIDGE_logError("Number of tip names (%u) must be same as number of sub-groups (%u)", tips_in.size(), sub_groups.size());
     return false;
   }
 
   if (!consistency_limits.empty() && consistency_limits.size() != sub_groups.size())
   {
-    logError("Number of consistency limit vectors must be the same as number of sub-groups");
+    CONSOLE_BRIDGE_logError("Number of consistency limit vectors must be the same as number of sub-groups");
     return false;
   }
 
@@ -1718,7 +1718,7 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
   {
     if (consistency_limits[i].size() != sub_groups[i]->getVariableCount())
     {
-      logError("Number of joints in consistency_limits is %u but it should be should be %u", (unsigned int)i,
+      CONSOLE_BRIDGE_logError("Number of joints in consistency_limits is %u but it should be should be %u", (unsigned int)i,
                sub_groups[i]->getVariableCount());
       return false;
     }
@@ -1731,7 +1731,7 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
     kinematics::KinematicsBaseConstPtr solver = sub_groups[i]->getSolverInstance();
     if (!solver)
     {
-      logError("Could not find solver for group '%s'", sub_groups[i]->getName().c_str());
+      CONSOLE_BRIDGE_logError("Could not find solver for group '%s'", sub_groups[i]->getName().c_str());
       return false;
     }
     solvers.push_back(solver);
@@ -1767,7 +1767,7 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
         const EigenSTL::vector_Affine3d& ab_trans = ab->getFixedTransforms();
         if (ab_trans.size() != 1)
         {
-          logError("Cannot use an attached body with multiple geometries as a reference frame.");
+          CONSOLE_BRIDGE_logError("Cannot use an attached body with multiple geometries as a reference frame.");
           return false;
         }
         pose_frame = ab->getAttachedLinkName();
@@ -1791,7 +1791,7 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
 
     if (pose_frame != solver_tip_frame)
     {
-      logError("Cannot compute IK for query pose reference frame '%s', desired: '%s'", pose_frame.c_str(),
+      CONSOLE_BRIDGE_logError("Cannot compute IK for query pose reference frame '%s', desired: '%s'", pose_frame.c_str(),
                solver_tip_frame.c_str());
       return false;
     }
@@ -1865,7 +1865,7 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
         found_solution = false;
         break;
       }
-      logDebug("IK attempt: %d of %d", st, attempts);
+      CONSOLE_BRIDGE_logDebug("IK attempt: %d of %d", st, attempts);
     }
     if (found_solution)
     {
@@ -1873,7 +1873,7 @@ bool moveit::core::RobotState::setFromIKSubgroups(const JointModelGroup* jmg, co
       copyJointGroupPositions(jmg, full_solution);
       if (constraint ? constraint(this, jmg, &full_solution[0]) : true)
       {
-        logDebug("Found IK solution");
+        CONSOLE_BRIDGE_logDebug("Found IK solution");
         return true;
       }
     }
@@ -1976,7 +1976,7 @@ double moveit::core::RobotState::testJointSpaceJump(const JointModelGroup* group
   for (std::size_t i = 0; i < dist_vector.size(); ++i)
     if (dist_vector[i] > thres)
     {
-      logDebug("Truncating Cartesian path due to detected jump in joint-space distance");
+      CONSOLE_BRIDGE_logDebug("Truncating Cartesian path due to detected jump in joint-space distance");
       percentage = (double)i / (double)dist_vector.size();
       traj.resize(i);
       break;
diff --git a/robot_trajectory/src/robot_trajectory.cpp b/robot_trajectory/src/robot_trajectory.cpp
index 44f4fad..d55ef1b 100644
--- a/robot_trajectory/src/robot_trajectory.cpp
+++ b/robot_trajectory/src/robot_trajectory.cpp
@@ -458,7 +458,7 @@ bool robot_trajectory::RobotTrajectory::getStateAtDurationFromStart(const double
   int before = 0, after = 0;
   double blend = 1.0;
   findWayPointIndicesForDurationAfterStart(request_duration, before, after, blend);
-  // logDebug("Interpolating %.3f of the way between index %d and %d.", blend, before, after);
+  // CONSOLE_BRIDGE_logDebug("Interpolating %.3f of the way between index %d and %d.", blend, before, after);
   waypoints_[before]->interpolate(*waypoints_[after], blend, *output_state);
   return true;
 }
diff --git a/trajectory_processing/src/iterative_time_parameterization.cpp b/trajectory_processing/src/iterative_time_parameterization.cpp
index f30d0f5..bfcd11f 100644
--- a/trajectory_processing/src/iterative_time_parameterization.cpp
+++ b/trajectory_processing/src/iterative_time_parameterization.cpp
@@ -59,20 +59,20 @@ namespace
 {
 void printPoint(const trajectory_msgs::JointTrajectoryPoint& point, std::size_t i)
 {
-  logDebug(" time   [%i]= %f", i, point.time_from_start.toSec());
+  CONSOLE_BRIDGE_logDebug(" time   [%i]= %f", i, point.time_from_start.toSec());
   if (point.positions.size() >= 7)
   {
-    logDebug(" pos_   [%i]= %f %f %f %f %f %f %f", i, point.positions[0], point.positions[1], point.positions[2],
+    CONSOLE_BRIDGE_logDebug(" pos_   [%i]= %f %f %f %f %f %f %f", i, point.positions[0], point.positions[1], point.positions[2],
              point.positions[3], point.positions[4], point.positions[5], point.positions[6]);
   }
   if (point.velocities.size() >= 7)
   {
-    logDebug("  vel_  [%i]= %f %f %f %f %f %f %f", i, point.velocities[0], point.velocities[1], point.velocities[2],
+    CONSOLE_BRIDGE_logDebug("  vel_  [%i]= %f %f %f %f %f %f %f", i, point.velocities[0], point.velocities[1], point.velocities[2],
              point.velocities[3], point.velocities[4], point.velocities[5], point.velocities[6]);
   }
   if (point.accelerations.size() >= 7)
   {
-    logDebug("   acc_ [%i]= %f %f %f %f %f %f %f", i, point.accelerations[0], point.accelerations[1],
+    CONSOLE_BRIDGE_logDebug("   acc_ [%i]= %f %f %f %f %f %f %f", i, point.accelerations[0], point.accelerations[1],
              point.accelerations[2], point.accelerations[3], point.accelerations[4], point.accelerations[5],
              point.accelerations[6]);
   }
@@ -80,13 +80,13 @@ void printPoint(const trajectory_msgs::JointTrajectoryPoint& point, std::size_t
 
 void printStats(const trajectory_msgs::JointTrajectory& trajectory, const std::vector<moveit_msgs::JointLimits>& limits)
 {
-  logDebug("jointNames= %s %s %s %s %s %s %s", limits[0].joint_name.c_str(), limits[1].joint_name.c_str(),
+  CONSOLE_BRIDGE_logDebug("jointNames= %s %s %s %s %s %s %s", limits[0].joint_name.c_str(), limits[1].joint_name.c_str(),
            limits[2].joint_name.c_str(), limits[3].joint_name.c_str(), limits[4].joint_name.c_str(),
            limits[5].joint_name.c_str(), limits[6].joint_name.c_str());
-  logDebug("maxVelocities= %f %f %f %f %f %f %f", limits[0].max_velocity, limits[1].max_velocity,
+  CONSOLE_BRIDGE_logDebug("maxVelocities= %f %f %f %f %f %f %f", limits[0].max_velocity, limits[1].max_velocity,
            limits[2].max_velocity, limits[3].max_velocity, limits[4].max_velocity, limits[5].max_velocity,
            limits[6].max_velocity);
-  logDebug("maxAccelerations= %f %f %f %f %f %f %f", limits[0].max_acceleration, limits[1].max_acceleration,
+  CONSOLE_BRIDGE_logDebug("maxAccelerations= %f %f %f %f %f %f %f", limits[0].max_acceleration, limits[1].max_acceleration,
            limits[2].max_acceleration, limits[3].max_acceleration, limits[4].max_acceleration,
            limits[5].max_acceleration, limits[6].max_acceleration);
   // for every point in time:
@@ -111,9 +111,9 @@ void IterativeParabolicTimeParameterization::applyVelocityConstraints(robot_traj
   if (max_velocity_scaling_factor > 0.0 && max_velocity_scaling_factor <= 1.0)
     velocity_scaling_factor = max_velocity_scaling_factor;
   else if (max_velocity_scaling_factor == 0.0)
-    logDebug("A max_velocity_scaling_factor of 0.0 was specified, defaulting to %f instead.", velocity_scaling_factor);
+    CONSOLE_BRIDGE_logDebug("A max_velocity_scaling_factor of 0.0 was specified, defaulting to %f instead.", velocity_scaling_factor);
   else
-    logWarn("Invalid max_velocity_scaling_factor %f specified, defaulting to %f instead.", max_velocity_scaling_factor,
+    CONSOLE_BRIDGE_logWarn("Invalid max_velocity_scaling_factor %f specified, defaulting to %f instead.", max_velocity_scaling_factor,
             velocity_scaling_factor);
 
   for (int i = 0; i < num_points - 1; ++i)
@@ -324,10 +324,10 @@ void IterativeParabolicTimeParameterization::applyAccelerationConstraints(
   if (max_acceleration_scaling_factor > 0.0 && max_acceleration_scaling_factor <= 1.0)
     acceleration_scaling_factor = max_acceleration_scaling_factor;
   else if (max_acceleration_scaling_factor == 0.0)
-    logDebug("A max_acceleration_scaling_factor of 0.0 was specified, defaulting to %f instead.",
+    CONSOLE_BRIDGE_logDebug("A max_acceleration_scaling_factor of 0.0 was specified, defaulting to %f instead.",
              acceleration_scaling_factor);
   else
-    logWarn("Invalid max_acceleration_scaling_factor %f specified, defaulting to %f instead.",
+    CONSOLE_BRIDGE_logWarn("Invalid max_acceleration_scaling_factor %f specified, defaulting to %f instead.",
             max_acceleration_scaling_factor, acceleration_scaling_factor);
 
   do
@@ -445,7 +445,7 @@ void IterativeParabolicTimeParameterization::applyAccelerationConstraints(
         backwards = !backwards;
       }
     }
-    // logDebug("applyAcceleration: num_updates=%i", num_updates);
+    // CONSOLE_BRIDGE_logDebug("applyAcceleration: num_updates=%i", num_updates);
   } while (num_updates > 0 && iteration < static_cast<int>(max_iterations_));
 }
 
@@ -459,7 +459,7 @@ bool IterativeParabolicTimeParameterization::computeTimeStamps(robot_trajectory:
   const robot_model::JointModelGroup* group = trajectory.getGroup();
   if (!group)
   {
-    logError("It looks like the planner did not set the group the plan was computed for");
+    CONSOLE_BRIDGE_logError("It looks like the planner did not set the group the plan was computed for");
     return false;
   }
 
diff --git a/transforms/src/transforms.cpp b/transforms/src/transforms.cpp
index 395a7ed..c485913 100644
--- a/transforms/src/transforms.cpp
+++ b/transforms/src/transforms.cpp
@@ -43,12 +43,12 @@ moveit::core::Transforms::Transforms(const std::string& target_frame) : target_f
 {
   boost::trim(target_frame_);
   if (target_frame_.empty())
-    logError("The target frame for MoveIt Transforms cannot be empty.");
+    CONSOLE_BRIDGE_logError("The target frame for MoveIt Transforms cannot be empty.");
   else
   {
     if (target_frame_[0] != '/')
     {
-      logWarn("Frame '%s' specified as target frame for MoveIt Transforms. Assuming '/%s' instead.",
+      CONSOLE_BRIDGE_logWarn("Frame '%s' specified as target frame for MoveIt Transforms. Assuming '/%s' instead.",
               target_frame_.c_str(), target_frame_.c_str());
       target_frame_ = '/' + target_frame_;
     }
@@ -104,7 +104,7 @@ const Eigen::Affine3d& moveit::core::Transforms::getTransform(const std::string&
       return it->second;
   }
 
-  logError("Unable to transform from frame '%s' to frame '%s'. Returning identity.", from_frame.c_str(),
+  CONSOLE_BRIDGE_logError("Unable to transform from frame '%s' to frame '%s'. Returning identity.", from_frame.c_str(),
            target_frame_.c_str());
 
   // return identity
@@ -124,12 +124,12 @@ bool moveit::core::Transforms::canTransform(const std::string& from_frame) const
 void moveit::core::Transforms::setTransform(const Eigen::Affine3d& t, const std::string& from_frame)
 {
   if (from_frame.empty())
-    logError("Cannot record transform with empty name");
+    CONSOLE_BRIDGE_logError("Cannot record transform with empty name");
   else
   {
     if (from_frame[0] != '/')
     {
-      logWarn("Transform specified for frame '%s'. Assuming '/%s' instead", from_frame.c_str(), from_frame.c_str());
+      CONSOLE_BRIDGE_logWarn("Transform specified for frame '%s'. Assuming '/%s' instead", from_frame.c_str(), from_frame.c_str());
       transforms_['/' + from_frame] = t;
     }
     else
@@ -147,7 +147,7 @@ void moveit::core::Transforms::setTransform(const geometry_msgs::TransformStampe
   }
   else
   {
-    logError("Given transform is to frame '%s', but frame '%s' was expected.", transform.child_frame_id.c_str(),
+    CONSOLE_BRIDGE_logError("Given transform is to frame '%s', but frame '%s' was expected.", transform.child_frame_id.c_str(),
              target_frame_.c_str());
   }
 }
-- 
2.16.2

